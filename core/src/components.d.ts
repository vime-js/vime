/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { MediaCrossOriginOption, MediaPreloadOption } from "./components/providers/file/MediaFileProvider";
import { TooltipDirection, TooltipPosition } from "./components/ui/tooltip/types";
import { PlayerProps } from "./components/core/player/PlayerProps";
import { Logger } from "./components/core/player/PlayerLogger";
import { Params } from "./utils/network";
import { ViewType } from "./components/core/player/ViewType";
import { MediaResource } from "./components/providers/file/MediaResource";
import { PlayerProps as PlayerProps1 } from ".";
import { IconLibraryResolver } from "./components/ui/icon-library/IconRegistry";
import { Provider } from "./components/providers/Provider";
import { MediaType } from "./components/core/player/MediaType";
import { Translation } from "./components/core/player/lang/Translation";
import { AdapterHost, MediaProviderAdapter } from "./components/providers/MediaProvider";
import { SettingsController } from "./components/ui/settings/settings/SettingsController";
export namespace Components {
    interface VmAudio {
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLMediaElement>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; setCurrentTextTrack: (trackId: number) => Promise<void>; setTextTrackVisibility: (isVisible: boolean) => Promise<void>; }>;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "willAttach": boolean;
    }
    interface VmCaptionControl {
        /**
          * The URL to an SVG element or fragment to load.
         */
        "hideIcon": string;
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip": boolean;
        "i18n": PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        "isTextTrackVisible": PlayerProps['isTextTrackVisible'];
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        "playbackReady": PlayerProps['playbackReady'];
        /**
          * The URL to an SVG element or fragment to load.
         */
        "showIcon": string;
        "textTracks": PlayerProps['textTracks'];
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection": TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition": TooltipPosition;
    }
    interface VmCaptions {
        "currentTextTrack": PlayerProps['currentTextTrack'];
        /**
          * Whether the captions should be visible or not.
         */
        "hidden": boolean;
        "isControlsActive": PlayerProps['isControlsActive'];
        "isTextTrackVisible": PlayerProps['isTextTrackVisible'];
        "isVideoView": PlayerProps['isVideoView'];
        "playbackStarted": PlayerProps['playbackStarted'];
        "textTracks": PlayerProps['textTracks'];
    }
    interface VmClickToPlay {
        "forceClick": () => Promise<void>;
        "isMobile": PlayerProps['isMobile'];
        "isVideoView": PlayerProps['isVideoView'];
        "paused": PlayerProps['paused'];
        /**
          * By default this is disabled on mobile to not interfere with playback, set this to `true` to enable it.
         */
        "useOnMobile": boolean;
    }
    interface VmControl {
        /**
          * Removes focus from the control.
         */
        "blurControl": () => Promise<void>;
        /**
          * If the control has a popup menu, this indicates whether the menu is open or not. Sets the `aria-expanded` property.
         */
        "expanded"?: boolean;
        /**
          * Focuses the control.
         */
        "focusControl": () => Promise<void>;
        /**
          * Whether the control should be displayed or not.
         */
        "hidden": boolean;
        /**
          * The `id` attribute of the control.
         */
        "identifier"?: string;
        "isTouch": PlayerProps['isTouch'];
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        /**
          * The `aria-label` property of the control.
         */
        "label": string;
        /**
          * If the control has a popup menu, then this should be the `id` of said menu. Sets the `aria-controls` property.
         */
        "menu"?: string;
        /**
          * If the control is a toggle, this indicated whether the control is in a "pressed" state or not. Sets the `aria-pressed` property.
         */
        "pressed"?: boolean;
    }
    interface VmControlGroup {
        /**
          * Determines where to add spacing/margin. The amount of spacing is determined by the CSS variable `--control-group-spacing`.
         */
        "space": 'top' | 'bottom' | 'both' | 'none';
    }
    interface VmControlSpacer {
    }
    interface VmControls {
        /**
          * The length in milliseconds that the controls are active for before fading out. Audio players are not effected by this prop.
         */
        "activeDuration": number;
        /**
          * Sets the `align-items` flex property that aligns the individual controls on the cross-axis.
         */
        "align": 'start' | 'center' | 'end';
        /**
          * Sets the `flex-direction` property that manages the direction in which the controls are layed out.
         */
        "direction": 'row' | 'column';
        /**
          * Whether the controls container should be 100% height. This has no effect if the view is of type `audio`.
         */
        "fullHeight": boolean;
        /**
          * Whether the controls container should be 100% width. This has no effect if the view is of type `audio`.
         */
        "fullWidth": boolean;
        /**
          * Whether the controls are visible or not.
         */
        "hidden": boolean;
        /**
          * Whether the controls should hide when the mouse leaves the player. Audio players are not effected by this prop.
         */
        "hideOnMouseLeave": boolean;
        /**
          * Whether the controls should show/hide when paused. Audio players are not effected by this prop.
         */
        "hideWhenPaused": boolean;
        "isAudioView": PlayerProps['isAudioView'];
        "isControlsActive": PlayerProps['isControlsActive'];
        "isSettingsActive": PlayerProps['isSettingsActive'];
        /**
          * Sets the `justify-content` flex property that aligns the individual controls on the main-axis.
         */
        "justify": | 'start'
  | 'center'
  | 'end'
  | 'space-around'
  | 'space-between'
  | 'space-evenly';
        "paused": PlayerProps['paused'];
        /**
          * Pins the controls to the defined position inside the video player. This has no effect when the view is of type `audio`.
         */
        "pin": 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight' | 'center';
        "playbackReady": PlayerProps['playbackReady'];
        "playbackStarted": PlayerProps['playbackStarted'];
        /**
          * Whether the controls should wait for playback to start before being shown. Audio players are not effected by this prop.
         */
        "waitForPlaybackStart": boolean;
    }
    interface VmCurrentTime {
        /**
          * Whether the time should always show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours": boolean;
        "currentTime": PlayerProps['currentTime'];
        "i18n": PlayerProps['i18n'];
    }
    interface VmDailymotion {
        "autoplay": boolean;
        /**
          * Change the default highlight color used in the controls (hex value without the leading #). Color set in the Partner HQ will override this prop.
         */
        "color"?: string;
        "controls": boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLVmEmbedElement>; play: () => Promise<void>; pause: () => Promise<void>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackQuality: () => Promise<boolean>; setPlaybackQuality: (quality: string) => Promise<void>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<void>; exitFullscreen: () => Promise<void>; }>;
        "language": string;
        "logger"?: Logger;
        "loop": boolean;
        "muted": boolean;
        "playsinline": boolean;
        /**
          * The absolute URL of a custom poster to be used for the current video.
         */
        "poster"?: string;
        /**
          * Whether to automatically play the next video in the queue.
         */
        "shouldAutoplayQueue": boolean;
        /**
          * Whether to display the Dailymotion logo.
         */
        "showDailymotionLogo": boolean;
        /**
          * Whether to show buttons for sharing the video.
         */
        "showShareButtons": boolean;
        /**
          * Whether to show the 'Up Next' queue.
         */
        "showUpNextQueue": boolean;
        /**
          * Whether to show video information (title and owner) on the start screen.
         */
        "showVideoInfo": boolean;
        /**
          * Forwards your syndication key to the player.
         */
        "syndication"?: string;
        /**
          * The Dailymotion resource ID of the video to load.
         */
        "videoId": string;
    }
    interface VmDash {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        "autoplay": boolean;
        /**
          * The `dashjs` configuration.
         */
        "config": Record<string, any>;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        "currentTextTrack": number;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        /**
          * Are text tracks enabled by default.
         */
        "enableTextTracksByDefault": boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<any>; canPlay: (type: any) => Promise<boolean>; canSetPlaybackQuality: () => Promise<boolean>; setPlaybackQuality: (quality: string) => Promise<void>; setCurrentTextTrack: (trackId: number) => Promise<void>; setTextTrackVisibility: (isVisible: boolean) => Promise<void>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; }>;
        "isTextTrackVisible": boolean;
        /**
          * The URL where the `dashjs` library source can be found. If this property is used, then the `version` property is ignored.
         */
        "libSrc"?: string;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "shouldRenderNativeTextTracks": boolean;
        /**
          * The URL of the `manifest.mpd` file to use.
         */
        "src": string;
        /**
          * The NPM package version of the `dashjs` library to download and use.
         */
        "version": string;
    }
    interface VmDblClickFullscreen {
        "isFullscreenActive": PlayerProps['isFullscreenActive'];
        "isMobile": PlayerProps['isMobile'];
        "isVideoView": PlayerProps['isVideoView'];
        "playbackReady": PlayerProps['playbackReady'];
        /**
          * By default this is disabled on mobile to not interfere with playback, set this to `true` to enable it.
         */
        "useOnMobile": boolean;
    }
    interface VmDefaultControls {
        /**
          * The length in milliseconds that the controls are active for before fading out. Audio players are not effected by this prop.
         */
        "activeDuration": number;
        /**
          * Whether the controls should hide when the mouse leaves the player. Audio players are not effected by this prop.
         */
        "hideOnMouseLeave": boolean;
        /**
          * Whether the controls should show/hide when paused. Audio players are not effected by this prop.
         */
        "hideWhenPaused": boolean;
        "isAudioView": PlayerProps['isAudioView'];
        "isLive": PlayerProps['isLive'];
        "isMobile": PlayerProps['isMobile'];
        "isVideoView": PlayerProps['isVideoView'];
        "theme"?: PlayerProps['theme'];
        /**
          * Whether the controls should wait for playback to start before being shown. Audio players are not effected by this prop.
         */
        "waitForPlaybackStart": boolean;
    }
    interface VmDefaultSettings {
        "audioTracks": PlayerProps['audioTracks'];
        "currentAudioTrack": number;
        "currentTextTrack": number;
        "i18n": PlayerProps['i18n'];
        "isTextTrackVisible": boolean;
        "isVideoView": PlayerProps['isAudioView'];
        /**
          * Pins the settings to the defined position inside the video player. This has no effect when the view is of type `audio`, it will always be `bottomRight`.
         */
        "pin": 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';
        "playbackQualities": PlayerProps['playbackQualities'];
        "playbackQuality"?: PlayerProps['playbackQuality'];
        "playbackRate": PlayerProps['playbackRate'];
        "playbackRates": PlayerProps['playbackRates'];
        "playbackReady": PlayerProps['playbackReady'];
        "textTracks": PlayerProps['textTracks'];
    }
    interface VmDefaultUi {
        /**
          * Whether the custom captions UI should not be loaded.
         */
        "noCaptions": boolean;
        /**
          * Whether clicking the player should not toggle playback.
         */
        "noClickToPlay": boolean;
        /**
          * Whether the custom default controls should not be loaded.
         */
        "noControls": boolean;
        /**
          * Whether double clicking the player should not toggle fullscreen mode.
         */
        "noDblClickFullscreen": boolean;
        /**
          * Whether the default loading screen should not be loaded.
         */
        "noLoadingScreen": boolean;
        /**
          * Whether the custom poster UI should not be loaded.
         */
        "noPoster": boolean;
        /**
          * Whether the custom default settings menu should not be loaded.
         */
        "noSettings": boolean;
        /**
          * Whether the custom spinner UI should not be loaded.
         */
        "noSpinner": boolean;
    }
    interface VmEmbed {
        /**
          * A function which accepts the raw message received from the embedded media player via `postMessage` and converts it into a POJO.
         */
        "decoder"?: (
    data: string
  ) => Params | undefined;
        /**
          * A URL that will load the external player and media (Eg: https://www.youtube.com/embed/DyTCOwB0DVw).
         */
        "embedSrc": string;
        /**
          * The title of the current media so it can be set on the inner `iframe` for screen readers.
         */
        "mediaTitle": string;
        /**
          * Where the src request had originated from without any path information.
         */
        "origin"?: string;
        /**
          * The parameters to pass to the embedded player which are appended to the `embedSrc` prop. These can be passed in as a query string or object.
         */
        "params": string | Params;
        /**
          * Posts a message to the embedded media player.
         */
        "postMessage": (message: any, target?: string | undefined) => Promise<void>;
        /**
          * A collection of URLs to that the browser should immediately start establishing a connection with.
         */
        "preconnections": string[];
    }
    interface VmEndTime {
        /**
          * Whether the time should always show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours": boolean;
        "duration": PlayerProps['duration'];
        "i18n": PlayerProps['i18n'];
    }
    interface VmFile {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        "autoplay": boolean;
        "controls": boolean;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        "currentTextTrack": number;
        "currentTime": number;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLMediaElement>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; setCurrentTextTrack: (trackId: number) => Promise<void>; setTextTrackVisibility: (isVisible: boolean) => Promise<void>; }>;
        "hasCustomTextManager": boolean;
        "isTextTrackVisible": boolean;
        "language": string;
        "logger"?: Logger;
        "loop": boolean;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        "muted": boolean;
        "noConnect": boolean;
        "paused": boolean;
        /**
          * The playback rates that are available for this media.
         */
        "playbackRates": number[];
        "playbackReady": boolean;
        "playbackStarted": boolean;
        "playsinline": boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "shouldRenderNativeTextTracks": boolean;
        /**
          * Whether to use an `audio` or `video` element to play the media.
         */
        "viewType"?: ViewType;
        "volume": number;
        "willAttach": boolean;
    }
    interface VmFullscreenControl {
        /**
          * The name of the enter fullscreen icon to resolve from the icon library.
         */
        "enterIcon": string;
        /**
          * The name of the exit fullscreen icon to resolve from the icon library.
         */
        "exitIcon": string;
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip": boolean;
        "i18n": PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        "isFullscreenActive": PlayerProps['isFullscreenActive'];
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        "playbackReady": PlayerProps['playbackReady'];
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection": TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition": TooltipPosition;
    }
    interface VmHls {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        /**
          * The `hls.js` configuration.
         */
        "config"?: any;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<any>; canPlay: (type: any) => Promise<boolean>; canSetPlaybackQuality: () => Promise<boolean>; setPlaybackQuality: (quality: string) => Promise<void>; setCurrentAudioTrack: (trackId: number) => Promise<void>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; setCurrentTextTrack: (trackId: number) => Promise<void>; setTextTrackVisibility: (isVisible: boolean) => Promise<void>; }>;
        /**
          * The URL where the `hls.js` library source can be found. If this property is used, then the `version` property is ignored.
         */
        "libSrc"?: string;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        "playbackReady": boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        /**
          * The NPM package version of the `hls.js` library to download and use if HLS is not natively supported.
         */
        "version": string;
    }
    interface VmIcon {
        "icons": PlayerProps['icons'];
        /**
          * An alternative description to use for accessibility. If omitted, the name or src will be used to generate it.
         */
        "label"?: string;
        /**
          * The name of a registered icon library.
         */
        "library"?: string;
        /**
          * The name of the icon to draw.
         */
        "name"?: string;
        "redraw": () => Promise<void>;
        /**
          * The absolute URL of an SVG file to load.
         */
        "src"?: string;
    }
    interface VmIconLibrary {
        "icons": PlayerProps['icons'];
        /**
          * The name of the icon library to register. Vime provides some default libraries out of the box such as `vime`or `material`.
         */
        "name"?: string;
        /**
          * A function that translates an icon name to a URL where the corresponding SVG file exists. The URL can be local or a CORS-enabled endpoint.
         */
        "resolver"?: IconLibraryResolver;
    }
    interface VmLiveIndicator {
        "i18n": PlayerProps['i18n'];
        "isLive": PlayerProps['isLive'];
    }
    interface VmLoadingScreen {
        /**
          * Whether the loading dots are hidden or not.
         */
        "hideDots": boolean;
        "playbackReady": boolean;
    }
    interface VmMenu {
        /**
          * Whether the menu is open/visible.
         */
        "active": boolean;
        /**
          * Removes focus from the menu.
         */
        "blurMenu": () => Promise<void>;
        /**
          * Calculates the height of the settings menu based on its children.
         */
        "calculateHeight": () => Promise<number>;
        /**
          * Reference to the controller DOM element that is responsible for opening/closing this menu.
         */
        "controller"?: HTMLElement;
        /**
          * Focuses the menu.
         */
        "focusMenu": () => Promise<void>;
        /**
          * Returns the currently focused menu item.
         */
        "getActiveMenuItem": () => Promise<HTMLVmMenuItemElement | undefined>;
        /**
          * The `id` attribute of the menu.
         */
        "identifier": string;
        /**
          * Sets the currently focused menu item.
         */
        "setActiveMenuItem": (item?: HTMLVmMenuItemElement | undefined) => Promise<void>;
        /**
          * The direction the menu should slide in from.
         */
        "slideInDirection"?: 'left' | 'right';
    }
    interface VmMenuItem {
        /**
          * This can provide additional context about the value of a menu item. For example, if the item is a radio button for a set of video qualities, the badge could describe whether the quality is UHD, HD etc.
         */
        "badge"?: string;
        /**
          * Removes focus from the menu item.
         */
        "blurItem": () => Promise<void>;
        /**
          * The name of the checkmark icon to resolve from the icon library.
         */
        "checkIcon"?: string;
        /**
          * If this item is to behave as a radio button, then this property determines whether the radio is selected or not. Sets the `aria-checked` property.
         */
        "checked"?: boolean;
        /**
          * If the item has a popup menu, this indicates whether the menu is open or not. Sets the `aria-expanded` property.
         */
        "expanded"?: boolean;
        /**
          * Focuses the menu item.
         */
        "focusItem": () => Promise<void>;
        /**
          * Returns the height of the menu item.
         */
        "getHeight": () => Promise<number>;
        /**
          * Whether the item is displayed or not.
         */
        "hidden": boolean;
        /**
          * This can provide additional context about some underlying state of the item. For example, if the menu item opens/closes a submenu with options, the hint could be the currently selected option.
         */
        "hint"?: string;
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * The `id` attribute of the item.
         */
        "identifier"?: string;
        "isTouch": PlayerProps['isTouch'];
        /**
          * The label/title of the item.
         */
        "label": string;
        /**
          * If the item has a popup menu, then this should be a reference to it.
         */
        "menu"?: HTMLVmMenuElement;
    }
    interface VmMenuRadio {
        /**
          * This can provide additional context about the value. For example, if the option is for a set of video qualities, the badge could describe whether the quality is UHD, HD etc.
         */
        "badge"?: string;
        /**
          * The URL to an SVG element or fragment to load.
         */
        "checkIcon"?: string;
        /**
          * Whether the radio item is selected or not.
         */
        "checked": boolean;
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * The title of the radio item displayed to the user.
         */
        "label": string;
        /**
          * The value associated with this radio item.
         */
        "value": string;
    }
    interface VmMenuRadioGroup {
        /**
          * The current value selected for this group.
         */
        "value"?: string;
    }
    interface VmMuteControl {
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip": boolean;
        /**
          * The name of the high volume icon to resolve from the icon library.
         */
        "highVolumeIcon": string;
        "i18n": PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        /**
          * The name of the low volume icon to resolve from the icon library.
         */
        "lowVolumeIcon": string;
        "muted": PlayerProps['muted'];
        /**
          * The name of the muted volume icon to resolve from the icon library.
         */
        "mutedIcon": string;
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection": TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition": TooltipPosition;
        "volume": PlayerProps['volume'];
    }
    interface VmPipControl {
        /**
          * The name of the enter pip icon to resolve from the icon library.
         */
        "enterIcon": string;
        /**
          * The name of the exit pip icon to resolve from the icon library.
         */
        "exitIcon": string;
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip": boolean;
        "i18n": PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        "isPiPActive": PlayerProps['isPiPActive'];
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        "playbackReady": PlayerProps['playbackReady'];
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection": TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition": TooltipPosition;
    }
    interface VmPlaybackControl {
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip": boolean;
        "i18n": PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        /**
          * The name of the pause icon to resolve from the icon library.
         */
        "pauseIcon": string;
        "paused": PlayerProps['paused'];
        /**
          * The name of the play icon to resolve from the icon library.
         */
        "playIcon": string;
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection": TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition": TooltipPosition;
    }
    interface VmPlayer {
        /**
          * The aspect ratio of the player expressed as `width:height` (`16:9`). This is only applied if the `viewType` is `video` and the player is not in fullscreen mode.
          * @inheritDoc
         */
        "aspectRatio": string;
        /**
          * The audio tracks associated with the current media.
          * @inheritDoc 
          * @readonly
         */
        "audioTracks": never[];
        /**
          * Whether the player should automatically pause when another Vime player starts/resumes playback.
          * @inheritDoc
         */
        "autopause": boolean;
        /**
          * Whether playback should automatically begin playing once the media is ready to do so. This will only work if the browsers `autoplay` policies have been satisfied. It'll generally work if the player is muted, or the user frequently interacts with your site. You can check if it's possible to autoplay via the `canAutoplay()` or `canMutedAutoplay()` methods. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "autoplay": boolean;
        /**
          * The length of the media in seconds that has been downloaded by the browser.
          * @inheritDoc 
          * @readonly
         */
        "buffered": number;
        /**
          * Whether playback has temporarily stopped because of a lack of temporary data.
          * @inheritDoc 
          * @readonly
         */
        "buffering": boolean;
        "callAdapter": (method: keyof MediaProviderAdapter, value?: any) => Promise<any>;
        /**
          * Determines whether the player can start playback of the current media automatically.
          * @inheritDoc
         */
        "canAutoplay": () => Promise<boolean>;
        /**
          * Determines whether the player can start playback of the current media automatically given the player is muted.
          * @inheritDoc
         */
        "canMutedAutoplay": () => Promise<boolean>;
        /**
          * Determines whether the current provider recognizes, and can play the given type.
          * @inheritDoc
         */
        "canPlay": (type: string) => Promise<boolean>;
        /**
          * Returns whether the current providers allows changing the audio track.
          * @inheritDoc
         */
        "canSetAudioTrack": () => Promise<boolean>;
        /**
          * Returns whether the native browser fullscreen API is available, or the current provider can toggle fullscreen mode. This does not mean that the operation is guaranteed to be successful, only that it can be attempted.
          * @inheritDoc
         */
        "canSetFullscreen": () => Promise<boolean>;
        /**
          * Returns whether the current provider exposes an API for entering and exiting picture-in-picture mode. This does not mean the operation is guaranteed to be successful, only that it can be attempted.
          * @inheritDoc
         */
        "canSetPiP": () => Promise<boolean>;
        /**
          * Returns whether the current provider allows setting the `playbackQuality` prop.
          * @inheritDoc
         */
        "canSetPlaybackQuality": () => Promise<boolean>;
        /**
          * Returns whether the current provider allows setting the `playbackRate` prop.
          * @inheritDoc
         */
        "canSetPlaybackRate": () => Promise<boolean>;
        /**
          * Returns whether the current provider allows changing the text track.
          * @inheritDoc
         */
        "canSetTextTrack": () => Promise<boolean>;
        /**
          * Returns whether the current providers allows setting the text track visibility.
          * @inheritDoc
         */
        "canSetTextTrackVisibility": () => Promise<boolean>;
        /**
          * Indicates whether a user interface should be shown for controlling the resource. Set this to `false` when you want to provide your own custom controls, and `true` if you want the current provider to supply its own default controls. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "controls": boolean;
        /**
          * Gets the index of the currently active audio track. Defaults to `-1` to when the default audio track is used. If you'd like to set it than see the `setCurrentAudioTrack` method.
          * @inheritDoc 
          * @readonly
         */
        "currentAudioTrack": number;
        /**
          * The absolute URL of the poster for the current media resource. Defaults to `undefined` if no media/poster has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "currentPoster"?: string;
        /**
          * The current provider name whose responsible for loading and playing media. Defaults to `undefined` when no provider has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "currentProvider"?: Provider;
        /**
          * The absolute URL of the media resource that has been chosen. Defaults to `undefined` if no media has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "currentSrc"?: string;
        /**
          * Gets the index of the currently active text track. Defaults to `-1` to when all text tracks are disabled. If you'd like to set it than see the `setCurrentTextTrack` method.
          * @inheritDoc 
          * @readonly
         */
        "currentTextTrack": number;
        /**
          * A `double` indicating the current playback time in seconds. Defaults to `0` if the media has not started to play and has not seeked. Setting this value seeks the media to the new time. The value can be set to a minimum of `0` and maximum of the total length of the media (indicated by the duration prop).
          * @inheritDoc
         */
        "currentTime": number;
        /**
          * Whether the player is in debug mode and should `console.x` information about its internal state.
          * @inheritDoc
         */
        "debug": boolean;
        /**
          * A `double` indicating the total playback length of the media in seconds. Defaults to `-1` if no media has been loaded. If the media is being streamed live then the duration is equal to `Infinity`.
          * @inheritDoc 
          * @readonly
         */
        "duration": number;
        /**
          * Requests to enter fullscreen mode, returning a `Promise` that will resolve if the request is made, or reject with a reason for failure. This method will first attempt to use the browsers native fullscreen API, and then fallback to requesting the provider to do it (if available). Do not rely on a resolved promise to determine if the player is in fullscreen or not. The only way to be certain is by listening to the `vmFullscreenChange` event. Some common reasons for failure are: the fullscreen API is not available, the request is made when `viewType` is audio, or the user has not interacted with the page yet.
          * @inheritDoc
         */
        "enterFullscreen": (options?: FullscreenOptions | undefined) => Promise<any>;
        /**
          * Request to enter picture-in-picture (PiP) mode, returning a `Promise` that will resolve if the request is made, or reject with a reason for failure. Do not rely on a resolved promise to determine if the player is in PiP mode or not. The only way to be certain is by listening to the `vmPiPChange` event. Some common reasons for failure are the same as the reasons for `enterFullscreen()`.
          * @inheritDoc
         */
        "enterPiP": () => Promise<void | undefined>;
        /**
          * Requests to exit fullscreen mode, returning a `Promise` that will resolve if the request is successful, or reject with a reason for failure. Refer to `enterFullscreen()` for more information.
          * @inheritDoc
         */
        "exitFullscreen": () => Promise<any>;
        /**
          * Request to exit picture-in-picture mode, returns a `Promise` that will resolve if the request is successful, or reject with a reason for failure. Refer to `enterPiP()` for more information.
          * @inheritDoc
         */
        "exitPiP": () => Promise<void | undefined>;
        /**
          * Extends the translation map for a given language.
          * @inheritDoc
         */
        "extendLanguage": (language: string, translation: Partial<Translation>) => Promise<void>;
        /**
          * Returns the current media provider's adapter. Shorthand for `getProvider().getAdapter()`.
         */
        "getAdapter": <InternalPlayerType = any>() => Promise<MediaProviderAdapter<InternalPlayerType> | undefined>;
        /**
          * Returns the inner container.
         */
        "getContainer": () => Promise<HTMLDivElement | undefined>;
        /**
          * Returns the current media provider.
          * @inheritDoc
         */
        "getProvider": <InternalPlayerType = any>() => Promise<AdapterHost<InternalPlayerType> | undefined>;
        /**
          * A dictionary of translations for the current language.
          * @inheritDoc 
          * @readonly
         */
        "i18n": Translation;
        /**
          * The default icon library to be used throughout the player. You can use a predefined icon library such as vime, material, remix or boxicons. If you'd like to provide your own see the `<vm-icon-library>` component. Remember to pass in the name of your icon library here.
          * @inheritDoc
         */
        "icons": string;
        /**
          * Whether the current media is of type `audio`, shorthand for `mediaType === MediaType.Audio`.
          * @inheritDoc 
          * @readonly
         */
        "isAudio": boolean;
        /**
          * Whether the current view is of type `audio`, shorthand for `viewType === ViewType.Audio`.
          * @inheritDoc 
          * @readonly
         */
        "isAudioView": boolean;
        /**
          * Whether the controls are currently visible. This is currently only supported by custom controls.
          * @inheritDoc
         */
        "isControlsActive": boolean;
        /**
          * Whether the player is currently in fullscreen mode.
          * @inheritDoc 
          * @readonly
         */
        "isFullscreenActive": boolean;
        /**
          * Whether the current media is being broadcast live (`duration === Infinity`).
          * @inheritDoc 
          * @readonly
         */
        "isLive": boolean;
        /**
          * Whether the player is in mobile mode. This is determined by parsing `window.navigator.userAgent`.
          * @inheritDoc 
          * @readonly
         */
        "isMobile": boolean;
        /**
          * Whether the player is currently in picture-in-picture mode.
          * @inheritDoc 
          * @readonly
         */
        "isPiPActive": boolean;
        /**
          * Whether the settings menu has been opened and is currently visible. This is currently only supported by custom settings.
          * @inheritDoc 
          * @readonly
         */
        "isSettingsActive": boolean;
        /**
          * Whether the current text tracks is visible. If you'd like to set it than see the `setTrackTrackVisibility` method.
          * @inheritDoc 
          * @readonly
         */
        "isTextTrackVisible": boolean;
        /**
          * Whether the player is in touch mode. This is determined by listening for mouse/touch events and toggling this value.
          * @inheritDoc 
          * @readonly
         */
        "isTouch": boolean;
        /**
          * Whether the current media is of type `video`, shorthand for `mediaType === MediaType.Video`.
          * @inheritDoc 
          * @readonly
         */
        "isVideo": boolean;
        /**
          * Whether the current view is of type `video`, shorthand for `viewType === ViewType.Video`.
          * @inheritDoc 
          * @readonly
         */
        "isVideoView": boolean;
        /**
          * The current language of the player. This can be any code defined via the `extendLanguage` method or the default `en`. It's recommended to use an ISO 639-1 code as that'll be used by Vime when adding new language defaults in the future.
          * @inheritDoc
         */
        "language": string;
        /**
          * The languages that are currently available. You can add new languages via the `extendLanguage` method.
          * @inheritDoc 
          * @readonly
         */
        "languages": string[];
        /**
          * @readonly
         */
        "logger": Logger;
        /**
          * Whether media should automatically start playing from the beginning every time it ends.
          * @inheritDoc
         */
        "loop": boolean;
        /**
          * The title of the current media. Defaults to `undefined` if no media has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "mediaTitle"?: string;
        /**
          * The type of media that is currently active, whether it's audio or video. Defaults to `undefined` when no media has been loaded or the type cannot be determined.
          * @inheritDoc 
          * @readonly
         */
        "mediaType"?: MediaType;
        /**
          * Whether the audio is muted or not.
          * @inheritDoc
         */
        "muted": boolean;
        /**
          * Pauses playback of the media.
          * @inheritDoc
         */
        "pause": () => Promise<void | undefined>;
        /**
          * Whether playback should be paused. Defaults to `true` if no media has loaded or playback has not started. Setting this to `true` will begin/resume playback.
          * @inheritDoc
         */
        "paused": boolean;
        /**
          * Begins/resumes playback of the media. If this method is called programmatically before the user has interacted with the player, the promise may be rejected subject to the browser's autoplay policies.
          * @inheritDoc
         */
        "play": () => Promise<void | undefined>;
        /**
          * Whether media playback has reached the end. In other words it'll be true if `currentTime === duration`.
          * @inheritDoc 
          * @readonly
         */
        "playbackEnded": boolean;
        /**
          * The media qualities available for the current media.
          * @inheritDoc 
          * @readonly
         */
        "playbackQualities": string[];
        /**
          * Indicates the quality of the media. The value will differ between audio and video. For audio this might be some combination of the encoding format (AAC, MP3), bitrate in kilobits per second (kbps) and sample rate in kilohertz (kHZ). For video this will be the number of vertical pixels it supports. For example, if the video has a resolution of `1920x1080` then the quality will return `1080p`. Defaults to `undefined` which you can interpret as the quality is unknown. The value can also be `Auto` for adaptive bit streams (ABR), where the provider can automatically manage the playback quality. The quality can only be set to a quality found in the `playbackQualities` prop. Some providers may not allow changing the quality, you can check if it's possible via `canSetPlaybackQuality()`.
          * @inheritDoc
         */
        "playbackQuality"?: string;
        /**
          * A `double` indicating the rate at which media is being played back. If the value is `<1` then playback is slowed down; if `>1` then playback is sped up. Defaults to `1`. The playback rate can only be set to a rate found in the `playbackRates` prop. Some providers may not allow changing the playback rate, you can check if it's possible via `canSetPlaybackRate()`.
          * @inheritDoc
         */
        "playbackRate": number;
        /**
          * The playback rates available for the current media.
          * @inheritDoc 
          * @readonly
         */
        "playbackRates": number[];
        /**
          * Whether media is ready for playback to begin.
          * @inheritDoc 
          * @readonly
         */
        "playbackReady": boolean;
        /**
          * Whether the media has initiated playback. In other words it will be true if `currentTime > 0`.
          * @inheritDoc 
          * @readonly
         */
        "playbackStarted": boolean;
        /**
          * Whether media is actively playing back. Defaults to `false` if no media has loaded or playback has not started.
          * @inheritDoc 
          * @readonly
         */
        "playing": boolean;
        /**
          * Whether the video is to be played "inline", that is within the element's playback area. Note that setting this to false does not imply that the video will always be played in fullscreen. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "playsinline": boolean;
        /**
          * Whether the player has loaded and is ready to be interacted with.
          * @inheritDoc 
          * @readonly
         */
        "ready": boolean;
        /**
          * Whether the player is in the process of seeking to a new time position.
          * @inheritDoc 
          * @readonly
         */
        "seeking": boolean;
        /**
          * Sets the currently active audio track given the index.
          * @inheritDoc
         */
        "setCurrentAudioTrack": (trackId: number) => Promise<void>;
        /**
          * Sets the currently active text track given the index. Set to -1 to disable all text tracks.
          * @inheritDoc
         */
        "setCurrentTextTrack": (trackId: number) => Promise<void>;
        /**
          * Sets the visibility of the currently active text track.
          * @inheritDoc
         */
        "setTextTrackVisibility": (isVisible: boolean) => Promise<void>;
        /**
          * Whether text tracks should be rendered by native player, set to `false` if using custom display.
          * @inheritDoc
         */
        "shouldRenderNativeTextTracks": boolean;
        /**
          * The text tracks associated with the current media.
          * @inheritDoc 
          * @readonly
         */
        "textTracks": never[];
        /**
          * This property has no role other than scoping CSS selectors.
          * @inheritDoc
         */
        "theme"?: string;
        /**
          * Contains each language and its respective translation map.
          * @inheritDoc
         */
        "translations": Record<string, Translation>;
        /**
          * The type of player view that is being used, whether it's an audio player view or video player view. Normally if the media type is of audio then the view is of type audio, but in some cases it might be desirable to show a different view type. For example, when playing audio with a poster. This is subject to the provider allowing it. Defaults to `undefined` when no media has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "viewType"?: ViewType;
        /**
          * An `int` between `0` (silent) and `100` (loudest) indicating the audio volume.
          * @inheritDoc
         */
        "volume": number;
    }
    interface VmPoster {
        "currentPoster"?: PlayerProps['currentPoster'];
        "currentTime": PlayerProps['currentTime'];
        /**
          * How the poster image should be resized to fit the container (sets the `object-fit` property).
         */
        "fit"?: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none';
        "isVideoView": PlayerProps['isVideoView'];
        "mediaTitle"?: PlayerProps['mediaTitle'];
        "playbackStarted": PlayerProps['playbackStarted'];
    }
    interface VmScrim {
        /**
          * If this prop is defined, a dark gradient that smoothly fades out without being noticed will be used instead of a set color. This prop also sets the direction in which the dark end of the gradient should start. If the direction is set to `up`, the dark end of the gradient will start at the bottom of the player and fade out to the center. If the direction is set to `down`, the gradient will start at the top of the player and fade out to the center.
         */
        "gradient"?: 'up' | 'down';
        "isControlsActive": PlayerProps['isControlsActive'];
        "isVideoView": PlayerProps['isVideoView'];
    }
    interface VmScrubberControl {
        /**
          * Whether the timestamp in the tooltip should show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours": boolean;
        "buffered": PlayerProps['buffered'];
        "buffering": PlayerProps['buffering'];
        "currentTime": PlayerProps['currentTime'];
        "duration": PlayerProps['duration'];
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip": boolean;
        "i18n": PlayerProps['i18n'];
        /**
          * Prevents seeking forward/backward by using the Left/Right arrow keys.
         */
        "noKeyboard": boolean;
    }
    interface VmSettings {
        /**
          * Whether the settings menu is opened/closed.
         */
        "active": boolean;
        "isAudioView": PlayerProps['isAudioView'];
        "isMobile": PlayerProps['isMobile'];
        /**
          * Pins the settings to the defined position inside the video player. This has no effect when the view is of type `audio` (always `bottomRight`) and on mobile devices (always bottom sheet).
         */
        "pin": 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';
        /**
          * Sets the controller responsible for opening/closing this settings menu.
         */
        "setController": (controller: SettingsController) => Promise<void>;
    }
    interface VmSettingsControl {
        /**
          * Removes focus from the control.
         */
        "blurControl": () => Promise<void>;
        /**
          * Whether the settings menu this control manages is open.
         */
        "expanded": boolean;
        /**
          * Focuses the control.
         */
        "focusControl": () => Promise<void>;
        "i18n": PlayerProps['i18n'];
        /**
          * The name of the settings icon to resolve from the icon library.
         */
        "icon": string;
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * The DOM `id` of the settings menu this control is responsible for opening/closing.
         */
        "menu"?: string;
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection": TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition": TooltipPosition;
    }
    interface VmSkeleton {
        /**
          * Determines which animation effect the skeleton will use.
         */
        "effect": 'sheen' | 'none';
        "ready": PlayerProps['ready'];
    }
    interface VmSlider {
        /**
          * A human-readable label for the purpose of the slider.
         */
        "label"?: string;
        /**
          * The greatest permitted value.
         */
        "max": number;
        /**
          * The lowest value in the range of permitted values.
         */
        "min": number;
        /**
          * A number that specifies the granularity that the value must adhere to.
         */
        "step": number;
        /**
          * The current value.
         */
        "value": number;
        /**
          * Human-readable text alternative for the current value. Defaults to `value:max` percentage.
         */
        "valueText"?: string;
    }
    interface VmSpinner {
        "buffering": PlayerProps['buffering'];
        "currentProvider"?: PlayerProps['currentProvider'];
        "isVideoView": PlayerProps['isVideoView'];
        "playbackReady": PlayerProps['playbackReady'];
        /**
          * Whether the spinner should be active when the player is booting or media is loading.
         */
        "showWhenMediaLoading": boolean;
    }
    interface VmSubmenu {
        /**
          * Whether the submenu is open/closed.
         */
        "active": boolean;
        /**
          * Returns the controller (`vm-menu-item`) for this submenu.
         */
        "getController": () => Promise<HTMLVmMenuItemElement | undefined>;
        /**
          * Returns the height of the submenu controller.
         */
        "getControllerHeight": () => Promise<number>;
        /**
          * Returns the menu (`vm-menu`) for this submenu.
         */
        "getMenu": () => Promise<HTMLVmMenuElement | undefined>;
        /**
          * This can provide additional context about the current state of the submenu. For example, the hint could be the currently selected option if the submenu contains a radio group.
         */
        "hint"?: string;
        /**
          * The title of the submenu.
         */
        "label": string;
        /**
          * The direction the submenu should slide in from.
         */
        "slideInDirection"?: 'left' | 'right';
    }
    interface VmTime {
        /**
          * Whether the time should always show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours": boolean;
        /**
          * The `aria-label` property of the time.
         */
        "label": string;
        /**
          * The length of time in seconds.
         */
        "seconds": number;
    }
    interface VmTimeProgress {
        /**
          * Whether the times should always show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours": boolean;
        /**
          * The string used to separate the current time and end time.
         */
        "separator": string;
    }
    interface VmTooltip {
        /**
          * Whether the tooltip is visible or not.
         */
        "active": boolean;
        /**
          * Determines if the tooltip should grow according to its contents to the left/right. By default content grows outwards from the center.
         */
        "direction"?: TooltipDirection;
        /**
          * Whether the tooltip is displayed or not.
         */
        "hidden": boolean;
        "isMobile": PlayerProps['isMobile'];
        "isTouch": PlayerProps['isTouch'];
        /**
          * Determines if the tooltip appears on top/bottom of it's parent.
         */
        "position": TooltipPosition;
    }
    interface VmUi {
        "isFullscreenActive": PlayerProps['isFullscreenActive'];
        "isVideoView": PlayerProps['isVideoView'];
        "playsinline": PlayerProps['playsinline'];
    }
    interface VmVideo {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLMediaElement>; play: () => Promise<void | undefined>; pause: () => Promise<void | undefined>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; canSetPiP: () => Promise<boolean>; enterPiP: () => Promise<any>; exitPiP: () => Promise<any>; canSetFullscreen: () => Promise<boolean>; enterFullscreen: () => Promise<any>; exitFullscreen: () => Promise<any>; setCurrentTextTrack: (trackId: number) => Promise<void>; setTextTrackVisibility: (isVisible: boolean) => Promise<void>; }>;
        "hasCustomTextManager": boolean;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "willAttach": boolean;
    }
    interface VmVimeo {
        "aspectRatio": string;
        "autoplay": boolean;
        /**
          * Whether to display the video owner's name.
         */
        "byline": boolean;
        /**
          * The hexadecimal color value of the playback controls. The embed settings of the video might override this value.
         */
        "color"?: string;
        "controls": boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLVmEmbedElement>; play: () => Promise<void>; pause: () => Promise<void>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; }>;
        "language": string;
        "logger"?: Logger;
        "loop": boolean;
        "muted": boolean;
        /**
          * Turns off automatically determining the aspect ratio of the current video.
         */
        "noAutoAspectRatio": boolean;
        "playsinline": boolean;
        /**
          * Whether to display the video owner's portrait.
         */
        "portrait": boolean;
        /**
          * The absolute URL of a custom poster to be used for the current video.
         */
        "poster"?: string;
        /**
          * The Vimeo resource ID of the video to load.
         */
        "videoId": string;
    }
    interface VmVolumeControl {
        /**
          * Whether the tooltip should be hidden.
         */
        "hideTooltip": boolean;
        /**
          * The name of the high volume icon to resolve from the icon library.
         */
        "highVolumeIcon": string;
        "i18n": PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        "isMobile": PlayerProps['isMobile'];
        /**
          * The name of the low volume icon to resolve from the icon library.
         */
        "lowVolumeIcon": string;
        /**
          * A pipe (`/`) separated string of JS keyboard keys, that when caught in a `keydown` event, will toggle the muted state of the player.
         */
        "muteKeys"?: string;
        "muted": PlayerProps['muted'];
        /**
          * The name of the muted volume icon to resolve from the icon library.
         */
        "mutedIcon": string;
        /**
          * Prevents the volume being changed using the Up/Down arrow keys.
         */
        "noKeyboard": boolean;
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection": TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition": TooltipPosition;
        "volume": PlayerProps['volume'];
    }
    interface VmYoutube {
        "autoplay": boolean;
        "controls": boolean;
        /**
          * Whether cookies should be enabled on the embed.
         */
        "cookies": boolean;
        "getAdapter": () => Promise<{ getInternalPlayer: () => Promise<HTMLVmEmbedElement>; play: () => Promise<void>; pause: () => Promise<void>; canPlay: (type: any) => Promise<boolean>; setCurrentTime: (time: number) => Promise<void>; setMuted: (muted: boolean) => Promise<void>; setVolume: (volume: number) => Promise<void>; canSetPlaybackRate: () => Promise<boolean>; setPlaybackRate: (rate: number) => Promise<void>; }>;
        "language": string;
        "logger"?: Logger;
        "loop": boolean;
        "muted": boolean;
        "playsinline": boolean;
        /**
          * The absolute URL of a custom poster to be used for the current video.
         */
        "poster"?: string;
        /**
          * Whether the fullscreen control should be shown.
         */
        "showFullscreenControl": boolean;
        /**
          * The YouTube resource ID of the video to load.
         */
        "videoId": string;
    }
}
declare global {
    interface HTMLVmAudioElement extends Components.VmAudio, HTMLStencilElement {
    }
    var HTMLVmAudioElement: {
        prototype: HTMLVmAudioElement;
        new (): HTMLVmAudioElement;
    };
    interface HTMLVmCaptionControlElement extends Components.VmCaptionControl, HTMLStencilElement {
    }
    var HTMLVmCaptionControlElement: {
        prototype: HTMLVmCaptionControlElement;
        new (): HTMLVmCaptionControlElement;
    };
    interface HTMLVmCaptionsElement extends Components.VmCaptions, HTMLStencilElement {
    }
    var HTMLVmCaptionsElement: {
        prototype: HTMLVmCaptionsElement;
        new (): HTMLVmCaptionsElement;
    };
    interface HTMLVmClickToPlayElement extends Components.VmClickToPlay, HTMLStencilElement {
    }
    var HTMLVmClickToPlayElement: {
        prototype: HTMLVmClickToPlayElement;
        new (): HTMLVmClickToPlayElement;
    };
    interface HTMLVmControlElement extends Components.VmControl, HTMLStencilElement {
    }
    var HTMLVmControlElement: {
        prototype: HTMLVmControlElement;
        new (): HTMLVmControlElement;
    };
    interface HTMLVmControlGroupElement extends Components.VmControlGroup, HTMLStencilElement {
    }
    var HTMLVmControlGroupElement: {
        prototype: HTMLVmControlGroupElement;
        new (): HTMLVmControlGroupElement;
    };
    interface HTMLVmControlSpacerElement extends Components.VmControlSpacer, HTMLStencilElement {
    }
    var HTMLVmControlSpacerElement: {
        prototype: HTMLVmControlSpacerElement;
        new (): HTMLVmControlSpacerElement;
    };
    interface HTMLVmControlsElement extends Components.VmControls, HTMLStencilElement {
    }
    var HTMLVmControlsElement: {
        prototype: HTMLVmControlsElement;
        new (): HTMLVmControlsElement;
    };
    interface HTMLVmCurrentTimeElement extends Components.VmCurrentTime, HTMLStencilElement {
    }
    var HTMLVmCurrentTimeElement: {
        prototype: HTMLVmCurrentTimeElement;
        new (): HTMLVmCurrentTimeElement;
    };
    interface HTMLVmDailymotionElement extends Components.VmDailymotion, HTMLStencilElement {
    }
    var HTMLVmDailymotionElement: {
        prototype: HTMLVmDailymotionElement;
        new (): HTMLVmDailymotionElement;
    };
    interface HTMLVmDashElement extends Components.VmDash, HTMLStencilElement {
    }
    var HTMLVmDashElement: {
        prototype: HTMLVmDashElement;
        new (): HTMLVmDashElement;
    };
    interface HTMLVmDblClickFullscreenElement extends Components.VmDblClickFullscreen, HTMLStencilElement {
    }
    var HTMLVmDblClickFullscreenElement: {
        prototype: HTMLVmDblClickFullscreenElement;
        new (): HTMLVmDblClickFullscreenElement;
    };
    interface HTMLVmDefaultControlsElement extends Components.VmDefaultControls, HTMLStencilElement {
    }
    var HTMLVmDefaultControlsElement: {
        prototype: HTMLVmDefaultControlsElement;
        new (): HTMLVmDefaultControlsElement;
    };
    interface HTMLVmDefaultSettingsElement extends Components.VmDefaultSettings, HTMLStencilElement {
    }
    var HTMLVmDefaultSettingsElement: {
        prototype: HTMLVmDefaultSettingsElement;
        new (): HTMLVmDefaultSettingsElement;
    };
    interface HTMLVmDefaultUiElement extends Components.VmDefaultUi, HTMLStencilElement {
    }
    var HTMLVmDefaultUiElement: {
        prototype: HTMLVmDefaultUiElement;
        new (): HTMLVmDefaultUiElement;
    };
    interface HTMLVmEmbedElement extends Components.VmEmbed, HTMLStencilElement {
    }
    var HTMLVmEmbedElement: {
        prototype: HTMLVmEmbedElement;
        new (): HTMLVmEmbedElement;
    };
    interface HTMLVmEndTimeElement extends Components.VmEndTime, HTMLStencilElement {
    }
    var HTMLVmEndTimeElement: {
        prototype: HTMLVmEndTimeElement;
        new (): HTMLVmEndTimeElement;
    };
    interface HTMLVmFileElement extends Components.VmFile, HTMLStencilElement {
    }
    var HTMLVmFileElement: {
        prototype: HTMLVmFileElement;
        new (): HTMLVmFileElement;
    };
    interface HTMLVmFullscreenControlElement extends Components.VmFullscreenControl, HTMLStencilElement {
    }
    var HTMLVmFullscreenControlElement: {
        prototype: HTMLVmFullscreenControlElement;
        new (): HTMLVmFullscreenControlElement;
    };
    interface HTMLVmHlsElement extends Components.VmHls, HTMLStencilElement {
    }
    var HTMLVmHlsElement: {
        prototype: HTMLVmHlsElement;
        new (): HTMLVmHlsElement;
    };
    interface HTMLVmIconElement extends Components.VmIcon, HTMLStencilElement {
    }
    var HTMLVmIconElement: {
        prototype: HTMLVmIconElement;
        new (): HTMLVmIconElement;
    };
    interface HTMLVmIconLibraryElement extends Components.VmIconLibrary, HTMLStencilElement {
    }
    var HTMLVmIconLibraryElement: {
        prototype: HTMLVmIconLibraryElement;
        new (): HTMLVmIconLibraryElement;
    };
    interface HTMLVmLiveIndicatorElement extends Components.VmLiveIndicator, HTMLStencilElement {
    }
    var HTMLVmLiveIndicatorElement: {
        prototype: HTMLVmLiveIndicatorElement;
        new (): HTMLVmLiveIndicatorElement;
    };
    interface HTMLVmLoadingScreenElement extends Components.VmLoadingScreen, HTMLStencilElement {
    }
    var HTMLVmLoadingScreenElement: {
        prototype: HTMLVmLoadingScreenElement;
        new (): HTMLVmLoadingScreenElement;
    };
    interface HTMLVmMenuElement extends Components.VmMenu, HTMLStencilElement {
    }
    var HTMLVmMenuElement: {
        prototype: HTMLVmMenuElement;
        new (): HTMLVmMenuElement;
    };
    interface HTMLVmMenuItemElement extends Components.VmMenuItem, HTMLStencilElement {
    }
    var HTMLVmMenuItemElement: {
        prototype: HTMLVmMenuItemElement;
        new (): HTMLVmMenuItemElement;
    };
    interface HTMLVmMenuRadioElement extends Components.VmMenuRadio, HTMLStencilElement {
    }
    var HTMLVmMenuRadioElement: {
        prototype: HTMLVmMenuRadioElement;
        new (): HTMLVmMenuRadioElement;
    };
    interface HTMLVmMenuRadioGroupElement extends Components.VmMenuRadioGroup, HTMLStencilElement {
    }
    var HTMLVmMenuRadioGroupElement: {
        prototype: HTMLVmMenuRadioGroupElement;
        new (): HTMLVmMenuRadioGroupElement;
    };
    interface HTMLVmMuteControlElement extends Components.VmMuteControl, HTMLStencilElement {
    }
    var HTMLVmMuteControlElement: {
        prototype: HTMLVmMuteControlElement;
        new (): HTMLVmMuteControlElement;
    };
    interface HTMLVmPipControlElement extends Components.VmPipControl, HTMLStencilElement {
    }
    var HTMLVmPipControlElement: {
        prototype: HTMLVmPipControlElement;
        new (): HTMLVmPipControlElement;
    };
    interface HTMLVmPlaybackControlElement extends Components.VmPlaybackControl, HTMLStencilElement {
    }
    var HTMLVmPlaybackControlElement: {
        prototype: HTMLVmPlaybackControlElement;
        new (): HTMLVmPlaybackControlElement;
    };
    interface HTMLVmPlayerElement extends Components.VmPlayer, HTMLStencilElement {
    }
    var HTMLVmPlayerElement: {
        prototype: HTMLVmPlayerElement;
        new (): HTMLVmPlayerElement;
    };
    interface HTMLVmPosterElement extends Components.VmPoster, HTMLStencilElement {
    }
    var HTMLVmPosterElement: {
        prototype: HTMLVmPosterElement;
        new (): HTMLVmPosterElement;
    };
    interface HTMLVmScrimElement extends Components.VmScrim, HTMLStencilElement {
    }
    var HTMLVmScrimElement: {
        prototype: HTMLVmScrimElement;
        new (): HTMLVmScrimElement;
    };
    interface HTMLVmScrubberControlElement extends Components.VmScrubberControl, HTMLStencilElement {
    }
    var HTMLVmScrubberControlElement: {
        prototype: HTMLVmScrubberControlElement;
        new (): HTMLVmScrubberControlElement;
    };
    interface HTMLVmSettingsElement extends Components.VmSettings, HTMLStencilElement {
    }
    var HTMLVmSettingsElement: {
        prototype: HTMLVmSettingsElement;
        new (): HTMLVmSettingsElement;
    };
    interface HTMLVmSettingsControlElement extends Components.VmSettingsControl, HTMLStencilElement {
    }
    var HTMLVmSettingsControlElement: {
        prototype: HTMLVmSettingsControlElement;
        new (): HTMLVmSettingsControlElement;
    };
    interface HTMLVmSkeletonElement extends Components.VmSkeleton, HTMLStencilElement {
    }
    var HTMLVmSkeletonElement: {
        prototype: HTMLVmSkeletonElement;
        new (): HTMLVmSkeletonElement;
    };
    interface HTMLVmSliderElement extends Components.VmSlider, HTMLStencilElement {
    }
    var HTMLVmSliderElement: {
        prototype: HTMLVmSliderElement;
        new (): HTMLVmSliderElement;
    };
    interface HTMLVmSpinnerElement extends Components.VmSpinner, HTMLStencilElement {
    }
    var HTMLVmSpinnerElement: {
        prototype: HTMLVmSpinnerElement;
        new (): HTMLVmSpinnerElement;
    };
    interface HTMLVmSubmenuElement extends Components.VmSubmenu, HTMLStencilElement {
    }
    var HTMLVmSubmenuElement: {
        prototype: HTMLVmSubmenuElement;
        new (): HTMLVmSubmenuElement;
    };
    interface HTMLVmTimeElement extends Components.VmTime, HTMLStencilElement {
    }
    var HTMLVmTimeElement: {
        prototype: HTMLVmTimeElement;
        new (): HTMLVmTimeElement;
    };
    interface HTMLVmTimeProgressElement extends Components.VmTimeProgress, HTMLStencilElement {
    }
    var HTMLVmTimeProgressElement: {
        prototype: HTMLVmTimeProgressElement;
        new (): HTMLVmTimeProgressElement;
    };
    interface HTMLVmTooltipElement extends Components.VmTooltip, HTMLStencilElement {
    }
    var HTMLVmTooltipElement: {
        prototype: HTMLVmTooltipElement;
        new (): HTMLVmTooltipElement;
    };
    interface HTMLVmUiElement extends Components.VmUi, HTMLStencilElement {
    }
    var HTMLVmUiElement: {
        prototype: HTMLVmUiElement;
        new (): HTMLVmUiElement;
    };
    interface HTMLVmVideoElement extends Components.VmVideo, HTMLStencilElement {
    }
    var HTMLVmVideoElement: {
        prototype: HTMLVmVideoElement;
        new (): HTMLVmVideoElement;
    };
    interface HTMLVmVimeoElement extends Components.VmVimeo, HTMLStencilElement {
    }
    var HTMLVmVimeoElement: {
        prototype: HTMLVmVimeoElement;
        new (): HTMLVmVimeoElement;
    };
    interface HTMLVmVolumeControlElement extends Components.VmVolumeControl, HTMLStencilElement {
    }
    var HTMLVmVolumeControlElement: {
        prototype: HTMLVmVolumeControlElement;
        new (): HTMLVmVolumeControlElement;
    };
    interface HTMLVmYoutubeElement extends Components.VmYoutube, HTMLStencilElement {
    }
    var HTMLVmYoutubeElement: {
        prototype: HTMLVmYoutubeElement;
        new (): HTMLVmYoutubeElement;
    };
    interface HTMLElementTagNameMap {
        "vm-audio": HTMLVmAudioElement;
        "vm-caption-control": HTMLVmCaptionControlElement;
        "vm-captions": HTMLVmCaptionsElement;
        "vm-click-to-play": HTMLVmClickToPlayElement;
        "vm-control": HTMLVmControlElement;
        "vm-control-group": HTMLVmControlGroupElement;
        "vm-control-spacer": HTMLVmControlSpacerElement;
        "vm-controls": HTMLVmControlsElement;
        "vm-current-time": HTMLVmCurrentTimeElement;
        "vm-dailymotion": HTMLVmDailymotionElement;
        "vm-dash": HTMLVmDashElement;
        "vm-dbl-click-fullscreen": HTMLVmDblClickFullscreenElement;
        "vm-default-controls": HTMLVmDefaultControlsElement;
        "vm-default-settings": HTMLVmDefaultSettingsElement;
        "vm-default-ui": HTMLVmDefaultUiElement;
        "vm-embed": HTMLVmEmbedElement;
        "vm-end-time": HTMLVmEndTimeElement;
        "vm-file": HTMLVmFileElement;
        "vm-fullscreen-control": HTMLVmFullscreenControlElement;
        "vm-hls": HTMLVmHlsElement;
        "vm-icon": HTMLVmIconElement;
        "vm-icon-library": HTMLVmIconLibraryElement;
        "vm-live-indicator": HTMLVmLiveIndicatorElement;
        "vm-loading-screen": HTMLVmLoadingScreenElement;
        "vm-menu": HTMLVmMenuElement;
        "vm-menu-item": HTMLVmMenuItemElement;
        "vm-menu-radio": HTMLVmMenuRadioElement;
        "vm-menu-radio-group": HTMLVmMenuRadioGroupElement;
        "vm-mute-control": HTMLVmMuteControlElement;
        "vm-pip-control": HTMLVmPipControlElement;
        "vm-playback-control": HTMLVmPlaybackControlElement;
        "vm-player": HTMLVmPlayerElement;
        "vm-poster": HTMLVmPosterElement;
        "vm-scrim": HTMLVmScrimElement;
        "vm-scrubber-control": HTMLVmScrubberControlElement;
        "vm-settings": HTMLVmSettingsElement;
        "vm-settings-control": HTMLVmSettingsControlElement;
        "vm-skeleton": HTMLVmSkeletonElement;
        "vm-slider": HTMLVmSliderElement;
        "vm-spinner": HTMLVmSpinnerElement;
        "vm-submenu": HTMLVmSubmenuElement;
        "vm-time": HTMLVmTimeElement;
        "vm-time-progress": HTMLVmTimeProgressElement;
        "vm-tooltip": HTMLVmTooltipElement;
        "vm-ui": HTMLVmUiElement;
        "vm-video": HTMLVmVideoElement;
        "vm-vimeo": HTMLVmVimeoElement;
        "vm-volume-control": HTMLVmVolumeControlElement;
        "vm-youtube": HTMLVmYoutubeElement;
    }
}
declare namespace LocalJSX {
    interface VmAudio {
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "willAttach"?: boolean;
    }
    interface VmCaptionControl {
        /**
          * The URL to an SVG element or fragment to load.
         */
        "hideIcon"?: string;
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip"?: boolean;
        "i18n"?: PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        "isTextTrackVisible"?: PlayerProps['isTextTrackVisible'];
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        "playbackReady"?: PlayerProps['playbackReady'];
        /**
          * The URL to an SVG element or fragment to load.
         */
        "showIcon"?: string;
        "textTracks"?: PlayerProps['textTracks'];
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection"?: TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition"?: TooltipPosition;
    }
    interface VmCaptions {
        "currentTextTrack"?: PlayerProps['currentTextTrack'];
        /**
          * Whether the captions should be visible or not.
         */
        "hidden"?: boolean;
        "isControlsActive"?: PlayerProps['isControlsActive'];
        "isTextTrackVisible"?: PlayerProps['isTextTrackVisible'];
        "isVideoView"?: PlayerProps['isVideoView'];
        "playbackStarted"?: PlayerProps['playbackStarted'];
        "textTracks"?: PlayerProps['textTracks'];
    }
    interface VmClickToPlay {
        "isMobile"?: PlayerProps['isMobile'];
        "isVideoView"?: PlayerProps['isVideoView'];
        "paused"?: PlayerProps['paused'];
        /**
          * By default this is disabled on mobile to not interfere with playback, set this to `true` to enable it.
         */
        "useOnMobile"?: boolean;
    }
    interface VmControl {
        /**
          * If the control has a popup menu, this indicates whether the menu is open or not. Sets the `aria-expanded` property.
         */
        "expanded"?: boolean;
        /**
          * Whether the control should be displayed or not.
         */
        "hidden"?: boolean;
        /**
          * The `id` attribute of the control.
         */
        "identifier"?: string;
        "isTouch"?: PlayerProps['isTouch'];
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        /**
          * The `aria-label` property of the control.
         */
        "label": string;
        /**
          * If the control has a popup menu, then this should be the `id` of said menu. Sets the `aria-controls` property.
         */
        "menu"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onVmBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control receives focus.
         */
        "onVmFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the user is interacting with the control by focusing, touching or hovering on it.
         */
        "onVmInteractionChange"?: (event: CustomEvent<boolean>) => void;
        /**
          * If the control is a toggle, this indicated whether the control is in a "pressed" state or not. Sets the `aria-pressed` property.
         */
        "pressed"?: boolean;
    }
    interface VmControlGroup {
        /**
          * Determines where to add spacing/margin. The amount of spacing is determined by the CSS variable `--control-group-spacing`.
         */
        "space"?: 'top' | 'bottom' | 'both' | 'none';
    }
    interface VmControlSpacer {
    }
    interface VmControls {
        /**
          * The length in milliseconds that the controls are active for before fading out. Audio players are not effected by this prop.
         */
        "activeDuration"?: number;
        /**
          * Sets the `align-items` flex property that aligns the individual controls on the cross-axis.
         */
        "align"?: 'start' | 'center' | 'end';
        /**
          * Sets the `flex-direction` property that manages the direction in which the controls are layed out.
         */
        "direction"?: 'row' | 'column';
        /**
          * Whether the controls container should be 100% height. This has no effect if the view is of type `audio`.
         */
        "fullHeight"?: boolean;
        /**
          * Whether the controls container should be 100% width. This has no effect if the view is of type `audio`.
         */
        "fullWidth"?: boolean;
        /**
          * Whether the controls are visible or not.
         */
        "hidden"?: boolean;
        /**
          * Whether the controls should hide when the mouse leaves the player. Audio players are not effected by this prop.
         */
        "hideOnMouseLeave"?: boolean;
        /**
          * Whether the controls should show/hide when paused. Audio players are not effected by this prop.
         */
        "hideWhenPaused"?: boolean;
        "isAudioView"?: PlayerProps['isAudioView'];
        "isControlsActive"?: PlayerProps['isControlsActive'];
        "isSettingsActive"?: PlayerProps['isSettingsActive'];
        /**
          * Sets the `justify-content` flex property that aligns the individual controls on the main-axis.
         */
        "justify"?: | 'start'
  | 'center'
  | 'end'
  | 'space-around'
  | 'space-between'
  | 'space-evenly';
        "paused"?: PlayerProps['paused'];
        /**
          * Pins the controls to the defined position inside the video player. This has no effect when the view is of type `audio`.
         */
        "pin"?: 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight' | 'center';
        "playbackReady"?: PlayerProps['playbackReady'];
        "playbackStarted"?: PlayerProps['playbackStarted'];
        /**
          * Whether the controls should wait for playback to start before being shown. Audio players are not effected by this prop.
         */
        "waitForPlaybackStart"?: boolean;
    }
    interface VmCurrentTime {
        /**
          * Whether the time should always show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours"?: boolean;
        "currentTime"?: PlayerProps['currentTime'];
        "i18n"?: PlayerProps['i18n'];
    }
    interface VmDailymotion {
        "autoplay"?: boolean;
        /**
          * Change the default highlight color used in the controls (hex value without the leading #). Color set in the Partner HQ will override this prop.
         */
        "color"?: string;
        "controls"?: boolean;
        "language"?: string;
        "logger"?: Logger;
        "loop"?: boolean;
        "muted"?: boolean;
        /**
          * Emitted when an error has occurred.
         */
        "onVmError"?: (event: CustomEvent<string | undefined>) => void;
        "onVmLoadStart"?: (event: CustomEvent<void>) => void;
        "playsinline"?: boolean;
        /**
          * The absolute URL of a custom poster to be used for the current video.
         */
        "poster"?: string;
        /**
          * Whether to automatically play the next video in the queue.
         */
        "shouldAutoplayQueue"?: boolean;
        /**
          * Whether to display the Dailymotion logo.
         */
        "showDailymotionLogo"?: boolean;
        /**
          * Whether to show buttons for sharing the video.
         */
        "showShareButtons"?: boolean;
        /**
          * Whether to show the 'Up Next' queue.
         */
        "showUpNextQueue"?: boolean;
        /**
          * Whether to show video information (title and owner) on the start screen.
         */
        "showVideoInfo"?: boolean;
        /**
          * Forwards your syndication key to the player.
         */
        "syndication"?: string;
        /**
          * The Dailymotion resource ID of the video to load.
         */
        "videoId": string;
    }
    interface VmDash {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        "autoplay"?: boolean;
        /**
          * The `dashjs` configuration.
         */
        "config"?: Record<string, any>;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        "currentTextTrack"?: number;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        /**
          * Are text tracks enabled by default.
         */
        "enableTextTracksByDefault"?: boolean;
        "isTextTrackVisible"?: boolean;
        /**
          * The URL where the `dashjs` library source can be found. If this property is used, then the `version` property is ignored.
         */
        "libSrc"?: string;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        /**
          * Emitted when an error has occurred.
         */
        "onVmError"?: (event: CustomEvent<any>) => void;
        "onVmLoadStart"?: (event: CustomEvent<void>) => void;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "shouldRenderNativeTextTracks"?: boolean;
        /**
          * The URL of the `manifest.mpd` file to use.
         */
        "src": string;
        /**
          * The NPM package version of the `dashjs` library to download and use.
         */
        "version"?: string;
    }
    interface VmDblClickFullscreen {
        "isFullscreenActive"?: PlayerProps['isFullscreenActive'];
        "isMobile"?: PlayerProps['isMobile'];
        "isVideoView"?: PlayerProps['isVideoView'];
        "playbackReady"?: PlayerProps['playbackReady'];
        /**
          * By default this is disabled on mobile to not interfere with playback, set this to `true` to enable it.
         */
        "useOnMobile"?: boolean;
    }
    interface VmDefaultControls {
        /**
          * The length in milliseconds that the controls are active for before fading out. Audio players are not effected by this prop.
         */
        "activeDuration"?: number;
        /**
          * Whether the controls should hide when the mouse leaves the player. Audio players are not effected by this prop.
         */
        "hideOnMouseLeave"?: boolean;
        /**
          * Whether the controls should show/hide when paused. Audio players are not effected by this prop.
         */
        "hideWhenPaused"?: boolean;
        "isAudioView"?: PlayerProps['isAudioView'];
        "isLive"?: PlayerProps['isLive'];
        "isMobile"?: PlayerProps['isMobile'];
        "isVideoView"?: PlayerProps['isVideoView'];
        "theme"?: PlayerProps['theme'];
        /**
          * Whether the controls should wait for playback to start before being shown. Audio players are not effected by this prop.
         */
        "waitForPlaybackStart"?: boolean;
    }
    interface VmDefaultSettings {
        "audioTracks"?: PlayerProps['audioTracks'];
        "currentAudioTrack"?: number;
        "currentTextTrack"?: number;
        "i18n"?: PlayerProps['i18n'];
        "isTextTrackVisible"?: boolean;
        "isVideoView"?: PlayerProps['isAudioView'];
        /**
          * Pins the settings to the defined position inside the video player. This has no effect when the view is of type `audio`, it will always be `bottomRight`.
         */
        "pin"?: 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';
        "playbackQualities"?: PlayerProps['playbackQualities'];
        "playbackQuality"?: PlayerProps['playbackQuality'];
        "playbackRate"?: PlayerProps['playbackRate'];
        "playbackRates"?: PlayerProps['playbackRates'];
        "playbackReady"?: PlayerProps['playbackReady'];
        "textTracks"?: PlayerProps['textTracks'];
    }
    interface VmDefaultUi {
        /**
          * Whether the custom captions UI should not be loaded.
         */
        "noCaptions"?: boolean;
        /**
          * Whether clicking the player should not toggle playback.
         */
        "noClickToPlay"?: boolean;
        /**
          * Whether the custom default controls should not be loaded.
         */
        "noControls"?: boolean;
        /**
          * Whether double clicking the player should not toggle fullscreen mode.
         */
        "noDblClickFullscreen"?: boolean;
        /**
          * Whether the default loading screen should not be loaded.
         */
        "noLoadingScreen"?: boolean;
        /**
          * Whether the custom poster UI should not be loaded.
         */
        "noPoster"?: boolean;
        /**
          * Whether the custom default settings menu should not be loaded.
         */
        "noSettings"?: boolean;
        /**
          * Whether the custom spinner UI should not be loaded.
         */
        "noSpinner"?: boolean;
    }
    interface VmEmbed {
        /**
          * A function which accepts the raw message received from the embedded media player via `postMessage` and converts it into a POJO.
         */
        "decoder"?: (
    data: string
  ) => Params | undefined;
        /**
          * A URL that will load the external player and media (Eg: https://www.youtube.com/embed/DyTCOwB0DVw).
         */
        "embedSrc"?: string;
        /**
          * The title of the current media so it can be set on the inner `iframe` for screen readers.
         */
        "mediaTitle"?: string;
        /**
          * Emitted when the embedded player and any new media has loaded.
         */
        "onVmEmbedLoaded"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when a new message is received from the embedded player via `postMessage`.
         */
        "onVmEmbedMessage"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the `embedSrc` or `params` props change. The payload contains the `params` serialized into a query string and appended to `embedSrc`.
         */
        "onVmEmbedSrcChange"?: (event: CustomEvent<string>) => void;
        /**
          * Where the src request had originated from without any path information.
         */
        "origin"?: string;
        /**
          * The parameters to pass to the embedded player which are appended to the `embedSrc` prop. These can be passed in as a query string or object.
         */
        "params"?: string | Params;
        /**
          * A collection of URLs to that the browser should immediately start establishing a connection with.
         */
        "preconnections"?: string[];
    }
    interface VmEndTime {
        /**
          * Whether the time should always show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours"?: boolean;
        "duration"?: PlayerProps['duration'];
        "i18n"?: PlayerProps['i18n'];
    }
    interface VmFile {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        "autoplay"?: boolean;
        "controls"?: boolean;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        "currentTextTrack"?: number;
        "currentTime"?: number;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "hasCustomTextManager"?: boolean;
        "isTextTrackVisible"?: boolean;
        "language"?: string;
        "logger"?: Logger;
        "loop"?: boolean;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        "muted"?: boolean;
        "noConnect"?: boolean;
        /**
          * Emitted when an error has occurred.
         */
        "onVmError"?: (event: CustomEvent<any>) => void;
        "onVmLoadStart"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the underlying media element changes.
         */
        "onVmMediaElChange"?: (event: CustomEvent<HTMLAudioElement | HTMLVideoElement | undefined>) => void;
        /**
          * Emitted when the child `<source />` elements are modified.
         */
        "onVmSrcSetChange"?: (event: CustomEvent<MediaResource[]>) => void;
        "paused"?: boolean;
        /**
          * The playback rates that are available for this media.
         */
        "playbackRates"?: number[];
        "playbackReady"?: boolean;
        "playbackStarted"?: boolean;
        "playsinline"?: boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "shouldRenderNativeTextTracks"?: boolean;
        /**
          * Whether to use an `audio` or `video` element to play the media.
         */
        "viewType"?: ViewType;
        "volume"?: number;
        "willAttach"?: boolean;
    }
    interface VmFullscreenControl {
        /**
          * The name of the enter fullscreen icon to resolve from the icon library.
         */
        "enterIcon"?: string;
        /**
          * The name of the exit fullscreen icon to resolve from the icon library.
         */
        "exitIcon"?: string;
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip"?: boolean;
        "i18n"?: PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        "isFullscreenActive"?: PlayerProps['isFullscreenActive'];
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        "playbackReady"?: PlayerProps['playbackReady'];
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection"?: TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition"?: TooltipPosition;
    }
    interface VmHls {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        /**
          * The `hls.js` configuration.
         */
        "config"?: any;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        /**
          * The URL where the `hls.js` library source can be found. If this property is used, then the `version` property is ignored.
         */
        "libSrc"?: string;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        /**
          * Emitted when an error has occurred.
         */
        "onVmError"?: (event: CustomEvent<any>) => void;
        "onVmLoadStart"?: (event: CustomEvent<void>) => void;
        "playbackReady"?: boolean;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        /**
          * The NPM package version of the `hls.js` library to download and use if HLS is not natively supported.
         */
        "version"?: string;
    }
    interface VmIcon {
        "icons"?: PlayerProps['icons'];
        /**
          * An alternative description to use for accessibility. If omitted, the name or src will be used to generate it.
         */
        "label"?: string;
        /**
          * The name of a registered icon library.
         */
        "library"?: string;
        /**
          * The name of the icon to draw.
         */
        "name"?: string;
        /**
          * Emitted when the icon failed to load.
         */
        "onVmError"?: (event: CustomEvent<{ status?: number }>) => void;
        /**
          * Emitted when the icon has loaded.
         */
        "onVmLoad"?: (event: CustomEvent<void>) => void;
        /**
          * The absolute URL of an SVG file to load.
         */
        "src"?: string;
    }
    interface VmIconLibrary {
        "icons"?: PlayerProps['icons'];
        /**
          * The name of the icon library to register. Vime provides some default libraries out of the box such as `vime`or `material`.
         */
        "name"?: string;
        /**
          * A function that translates an icon name to a URL where the corresponding SVG file exists. The URL can be local or a CORS-enabled endpoint.
         */
        "resolver"?: IconLibraryResolver;
    }
    interface VmLiveIndicator {
        "i18n"?: PlayerProps['i18n'];
        "isLive"?: PlayerProps['isLive'];
    }
    interface VmLoadingScreen {
        /**
          * Whether the loading dots are hidden or not.
         */
        "hideDots"?: boolean;
        "playbackReady"?: boolean;
    }
    interface VmMenu {
        /**
          * Whether the menu is open/visible.
         */
        "active"?: boolean;
        /**
          * Reference to the controller DOM element that is responsible for opening/closing this menu.
         */
        "controller"?: HTMLElement;
        /**
          * The `id` attribute of the menu.
         */
        "identifier": string;
        /**
          * Emitted when the currently focused menu item changes.
         */
        "onVmActiveMenuItemChange"?: (event: CustomEvent<HTMLVmMenuItemElement | undefined>) => void;
        /**
          * Emitted when the active submenu changes.
         */
        "onVmActiveSubmenuChange"?: (event: CustomEvent<HTMLVmSubmenuElement | undefined>) => void;
        /**
          * Emitted when the menu loses focus.
         */
        "onVmBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the menu has closed/is not active.
         */
        "onVmClose"?: (event: CustomEvent<HTMLVmMenuElement>) => void;
        /**
          * Emitted when the menu is focused.
         */
        "onVmFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the height of the menu changes.
         */
        "onVmMenuHeightChange"?: (event: CustomEvent<number>) => void;
        /**
          * Emitted when the menu is open/active.
         */
        "onVmOpen"?: (event: CustomEvent<HTMLVmMenuElement>) => void;
        /**
          * The direction the menu should slide in from.
         */
        "slideInDirection"?: 'left' | 'right';
    }
    interface VmMenuItem {
        /**
          * This can provide additional context about the value of a menu item. For example, if the item is a radio button for a set of video qualities, the badge could describe whether the quality is UHD, HD etc.
         */
        "badge"?: string;
        /**
          * The name of the checkmark icon to resolve from the icon library.
         */
        "checkIcon"?: string;
        /**
          * If this item is to behave as a radio button, then this property determines whether the radio is selected or not. Sets the `aria-checked` property.
         */
        "checked"?: boolean;
        /**
          * If the item has a popup menu, this indicates whether the menu is open or not. Sets the `aria-expanded` property.
         */
        "expanded"?: boolean;
        /**
          * Whether the item is displayed or not.
         */
        "hidden"?: boolean;
        /**
          * This can provide additional context about some underlying state of the item. For example, if the menu item opens/closes a submenu with options, the hint could be the currently selected option.
         */
        "hint"?: string;
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * The `id` attribute of the item.
         */
        "identifier"?: string;
        "isTouch"?: PlayerProps['isTouch'];
        /**
          * The label/title of the item.
         */
        "label": string;
        /**
          * If the item has a popup menu, then this should be a reference to it.
         */
        "menu"?: HTMLVmMenuElement;
        /**
          * Emitted when the item loses focus.
         */
        "onVmBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the item is focused.
         */
        "onVmFocus"?: (event: CustomEvent<void>) => void;
    }
    interface VmMenuRadio {
        /**
          * This can provide additional context about the value. For example, if the option is for a set of video qualities, the badge could describe whether the quality is UHD, HD etc.
         */
        "badge"?: string;
        /**
          * The URL to an SVG element or fragment to load.
         */
        "checkIcon"?: string;
        /**
          * Whether the radio item is selected or not.
         */
        "checked"?: boolean;
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * The title of the radio item displayed to the user.
         */
        "label": string;
        /**
          * Emitted when the radio button is selected.
         */
        "onVmCheck"?: (event: CustomEvent<void>) => void;
        /**
          * The value associated with this radio item.
         */
        "value": string;
    }
    interface VmMenuRadioGroup {
        /**
          * Emitted when a new radio button is selected for this group.
         */
        "onVmCheck"?: (event: CustomEvent<void>) => void;
        /**
          * The current value selected for this group.
         */
        "value"?: string;
    }
    interface VmMuteControl {
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip"?: boolean;
        /**
          * The name of the high volume icon to resolve from the icon library.
         */
        "highVolumeIcon"?: string;
        "i18n"?: PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        /**
          * The name of the low volume icon to resolve from the icon library.
         */
        "lowVolumeIcon"?: string;
        "muted"?: PlayerProps['muted'];
        /**
          * The name of the muted volume icon to resolve from the icon library.
         */
        "mutedIcon"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onVmBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the control receives focus.
         */
        "onVmFocus"?: (event: CustomEvent<void>) => void;
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection"?: TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition"?: TooltipPosition;
        "volume"?: PlayerProps['volume'];
    }
    interface VmPipControl {
        /**
          * The name of the enter pip icon to resolve from the icon library.
         */
        "enterIcon"?: string;
        /**
          * The name of the exit pip icon to resolve from the icon library.
         */
        "exitIcon"?: string;
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip"?: boolean;
        "i18n"?: PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        "isPiPActive"?: PlayerProps['isPiPActive'];
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        "playbackReady"?: PlayerProps['playbackReady'];
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection"?: TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition"?: TooltipPosition;
    }
    interface VmPlaybackControl {
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip"?: boolean;
        "i18n"?: PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * A slash (`/`) separated string of JS keyboard keys (`KeyboardEvent.key`), that when caught in a `keydown` event, will trigger a `click` event on the control.
          * @inheritdoc
         */
        "keys"?: string;
        /**
          * The name of the pause icon to resolve from the icon library.
         */
        "pauseIcon"?: string;
        "paused"?: PlayerProps['paused'];
        /**
          * The name of the play icon to resolve from the icon library.
         */
        "playIcon"?: string;
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection"?: TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition"?: TooltipPosition;
    }
    interface VmPlayer {
        /**
          * The aspect ratio of the player expressed as `width:height` (`16:9`). This is only applied if the `viewType` is `video` and the player is not in fullscreen mode.
          * @inheritDoc
         */
        "aspectRatio"?: string;
        /**
          * The audio tracks associated with the current media.
          * @inheritDoc 
          * @readonly
         */
        "audioTracks"?: never[];
        /**
          * Whether the player should automatically pause when another Vime player starts/resumes playback.
          * @inheritDoc
         */
        "autopause"?: boolean;
        /**
          * Whether playback should automatically begin playing once the media is ready to do so. This will only work if the browsers `autoplay` policies have been satisfied. It'll generally work if the player is muted, or the user frequently interacts with your site. You can check if it's possible to autoplay via the `canAutoplay()` or `canMutedAutoplay()` methods. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "autoplay"?: boolean;
        /**
          * The length of the media in seconds that has been downloaded by the browser.
          * @inheritDoc 
          * @readonly
         */
        "buffered"?: number;
        /**
          * Whether playback has temporarily stopped because of a lack of temporary data.
          * @inheritDoc 
          * @readonly
         */
        "buffering"?: boolean;
        /**
          * Indicates whether a user interface should be shown for controlling the resource. Set this to `false` when you want to provide your own custom controls, and `true` if you want the current provider to supply its own default controls. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "controls"?: boolean;
        /**
          * Gets the index of the currently active audio track. Defaults to `-1` to when the default audio track is used. If you'd like to set it than see the `setCurrentAudioTrack` method.
          * @inheritDoc 
          * @readonly
         */
        "currentAudioTrack"?: number;
        /**
          * The absolute URL of the poster for the current media resource. Defaults to `undefined` if no media/poster has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "currentPoster"?: string;
        /**
          * The current provider name whose responsible for loading and playing media. Defaults to `undefined` when no provider has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "currentProvider"?: Provider;
        /**
          * The absolute URL of the media resource that has been chosen. Defaults to `undefined` if no media has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "currentSrc"?: string;
        /**
          * Gets the index of the currently active text track. Defaults to `-1` to when all text tracks are disabled. If you'd like to set it than see the `setCurrentTextTrack` method.
          * @inheritDoc 
          * @readonly
         */
        "currentTextTrack"?: number;
        /**
          * A `double` indicating the current playback time in seconds. Defaults to `0` if the media has not started to play and has not seeked. Setting this value seeks the media to the new time. The value can be set to a minimum of `0` and maximum of the total length of the media (indicated by the duration prop).
          * @inheritDoc
         */
        "currentTime"?: number;
        /**
          * Whether the player is in debug mode and should `console.x` information about its internal state.
          * @inheritDoc
         */
        "debug"?: boolean;
        /**
          * A `double` indicating the total playback length of the media in seconds. Defaults to `-1` if no media has been loaded. If the media is being streamed live then the duration is equal to `Infinity`.
          * @inheritDoc 
          * @readonly
         */
        "duration"?: number;
        /**
          * A dictionary of translations for the current language.
          * @inheritDoc 
          * @readonly
         */
        "i18n"?: Translation;
        /**
          * The default icon library to be used throughout the player. You can use a predefined icon library such as vime, material, remix or boxicons. If you'd like to provide your own see the `<vm-icon-library>` component. Remember to pass in the name of your icon library here.
          * @inheritDoc
         */
        "icons"?: string;
        /**
          * Whether the current media is of type `audio`, shorthand for `mediaType === MediaType.Audio`.
          * @inheritDoc 
          * @readonly
         */
        "isAudio"?: boolean;
        /**
          * Whether the current view is of type `audio`, shorthand for `viewType === ViewType.Audio`.
          * @inheritDoc 
          * @readonly
         */
        "isAudioView"?: boolean;
        /**
          * Whether the controls are currently visible. This is currently only supported by custom controls.
          * @inheritDoc
         */
        "isControlsActive"?: boolean;
        /**
          * Whether the player is currently in fullscreen mode.
          * @inheritDoc 
          * @readonly
         */
        "isFullscreenActive"?: boolean;
        /**
          * Whether the current media is being broadcast live (`duration === Infinity`).
          * @inheritDoc 
          * @readonly
         */
        "isLive"?: boolean;
        /**
          * Whether the player is in mobile mode. This is determined by parsing `window.navigator.userAgent`.
          * @inheritDoc 
          * @readonly
         */
        "isMobile"?: boolean;
        /**
          * Whether the player is currently in picture-in-picture mode.
          * @inheritDoc 
          * @readonly
         */
        "isPiPActive"?: boolean;
        /**
          * Whether the settings menu has been opened and is currently visible. This is currently only supported by custom settings.
          * @inheritDoc 
          * @readonly
         */
        "isSettingsActive"?: boolean;
        /**
          * Whether the current text tracks is visible. If you'd like to set it than see the `setTrackTrackVisibility` method.
          * @inheritDoc 
          * @readonly
         */
        "isTextTrackVisible"?: boolean;
        /**
          * Whether the player is in touch mode. This is determined by listening for mouse/touch events and toggling this value.
          * @inheritDoc 
          * @readonly
         */
        "isTouch"?: boolean;
        /**
          * Whether the current media is of type `video`, shorthand for `mediaType === MediaType.Video`.
          * @inheritDoc 
          * @readonly
         */
        "isVideo"?: boolean;
        /**
          * Whether the current view is of type `video`, shorthand for `viewType === ViewType.Video`.
          * @inheritDoc 
          * @readonly
         */
        "isVideoView"?: boolean;
        /**
          * The current language of the player. This can be any code defined via the `extendLanguage` method or the default `en`. It's recommended to use an ISO 639-1 code as that'll be used by Vime when adding new language defaults in the future.
          * @inheritDoc
         */
        "language"?: string;
        /**
          * The languages that are currently available. You can add new languages via the `extendLanguage` method.
          * @inheritDoc 
          * @readonly
         */
        "languages"?: string[];
        /**
          * @readonly
         */
        "logger"?: Logger;
        /**
          * Whether media should automatically start playing from the beginning every time it ends.
          * @inheritDoc
         */
        "loop"?: boolean;
        /**
          * The title of the current media. Defaults to `undefined` if no media has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "mediaTitle"?: string;
        /**
          * The type of media that is currently active, whether it's audio or video. Defaults to `undefined` when no media has been loaded or the type cannot be determined.
          * @inheritDoc 
          * @readonly
         */
        "mediaType"?: MediaType;
        /**
          * Whether the audio is muted or not.
          * @inheritDoc
         */
        "muted"?: boolean;
        /**
          * Emitted when the `audioTracks` prop changes value.
          * @inheritDoc
         */
        "onVmAudioTracksChange"?: (event: CustomEvent<PlayerProps['audioTracks']>) => void;
        /**
          * Emitted when the `buffered` prop changes value.
          * @inheritDoc
         */
        "onVmBufferedChange"?: (event: CustomEvent<PlayerProps['buffered']>) => void;
        /**
          * Emitted when the `buffering` prop changes value.
          * @inheritDoc
         */
        "onVmBufferingChange"?: (event: CustomEvent<PlayerProps['buffering']>) => void;
        /**
          * Emitted when the `isControlsActive` prop changes value.
          * @inheritDoc
         */
        "onVmControlsChange"?: (event: CustomEvent<PlayerProps['isControlsActive']>) => void;
        /**
          * Emitted when the `currentAudioTrack` prop changes value.
          * @inheritDoc
         */
        "onVmCurrentAudioTrackChange"?: (event: CustomEvent<PlayerProps['currentAudioTrack']>) => void;
        /**
          * Emitted when the `currentPoster` prop changes value.
          * @inheritDoc
         */
        "onVmCurrentPosterChange"?: (event: CustomEvent<PlayerProps['currentPoster']>) => void;
        /**
          * Emitted when the `currentProvider` prop changes value.
          * @inheritDoc
         */
        "onVmCurrentProviderChange"?: (event: CustomEvent<PlayerProps['currentProvider']>) => void;
        /**
          * Emitted when the `currentSrc` prop changes value.
          * @inheritDoc
         */
        "onVmCurrentSrcChange"?: (event: CustomEvent<PlayerProps['currentSrc']>) => void;
        /**
          * Emitted when the `currentTextTrack` prop changes value.
          * @inheritDoc
         */
        "onVmCurrentTextTrackChange"?: (event: CustomEvent<PlayerProps['currentTextTrack']>) => void;
        /**
          * Emitted when the `currentTime` prop changes value.
          * @inheritDoc
         */
        "onVmCurrentTimeChange"?: (event: CustomEvent<PlayerProps['currentTime']>) => void;
        /**
          * Emitted when the `duration` prop changes value.
          * @inheritDoc
         */
        "onVmDurationChange"?: (event: CustomEvent<PlayerProps['duration']>) => void;
        /**
          * Emitted when an any error has occurred within the player.
          * @inheritDoc
         */
        "onVmError"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the `isFullscreenActive` prop changes value.
          * @inheritDoc
         */
        "onVmFullscreenChange"?: (event: CustomEvent<PlayerProps['isFullscreenActive']>) => void;
        /**
          * Emitted when the `i18n` prop changes value.
          * @inheritDoc
         */
        "onVmI18nChange"?: (event: CustomEvent<PlayerProps['i18n']>) => void;
        /**
          * Emitted when the `language` prop changes value.
          * @inheritDoc
         */
        "onVmLanguageChange"?: (event: CustomEvent<PlayerProps['language']>) => void;
        /**
          * Emitted when the `languages` prop changes value.
          * @inheritDoc
         */
        "onVmLanguagesChange"?: (event: CustomEvent<PlayerProps['languages']>) => void;
        /**
          * Emitted when the `isLive` prop changes value.
          * @inheritDoc
         */
        "onVmLiveChange"?: (event: CustomEvent<PlayerProps['isLive']>) => void;
        /**
          * Emitted when the provider starts loading a media resource.
          * @inheritDoc
         */
        "onVmLoadStart"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the `mediaTitle` prop changes value.
          * @inheritDoc
         */
        "onVmMediaTitleChange"?: (event: CustomEvent<PlayerProps['mediaTitle']>) => void;
        /**
          * Emitted when the `mediaType` prop changes value.
          * @inheritDoc
         */
        "onVmMediaTypeChange"?: (event: CustomEvent<PlayerProps['mediaType']>) => void;
        /**
          * Emitted when the `muted` prop changes value.
          * @inheritDoc
         */
        "onVmMutedChange"?: (event: CustomEvent<PlayerProps['muted']>) => void;
        /**
          * Emitted when the `paused` prop changes value.
          * @inheritDoc
         */
        "onVmPausedChange"?: (event: CustomEvent<PlayerProps['paused']>) => void;
        /**
          * Emitted when the `isPiPActive` prop changes value.
          * @inheritDoc
         */
        "onVmPiPChange"?: (event: CustomEvent<PlayerProps['isPiPActive']>) => void;
        /**
          * Emitted when the media is transitioning from `paused` to `playing`. Event flow: `paused` -> `play` -> `playing`. The media starts `playing` once enough content has buffered to begin/resume playback.
          * @inheritDoc
         */
        "onVmPlay"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when playback reaches the end of the media.
          * @inheritDoc
         */
        "onVmPlaybackEnded"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the `playbackQualities` prop changes value.
          * @inheritDoc
         */
        "onVmPlaybackQualitiesChange"?: (event: CustomEvent<PlayerProps['playbackQualities']>) => void;
        /**
          * Emitted when the `playbackQuality` prop changes value.
          * @inheritDoc
         */
        "onVmPlaybackQualityChange"?: (event: CustomEvent<PlayerProps['playbackQuality']>) => void;
        /**
          * Emitted when the `playbackRate` prop changes value.
          * @inheritDoc
         */
        "onVmPlaybackRateChange"?: (event: CustomEvent<PlayerProps['playbackRate']>) => void;
        /**
          * Emitted when the `playbackRates` prop changes value.
          * @inheritDoc
         */
        "onVmPlaybackRatesChange"?: (event: CustomEvent<PlayerProps['playbackRates']>) => void;
        /**
          * Emitted when the media is ready to begin playback. The following props are guaranteed to be defined when this fires: `mediaTitle`, `currentSrc`, `currentPoster`, `duration`, `mediaType`, `viewType`.
          * @inheritDoc
         */
        "onVmPlaybackReady"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the media initiates playback.
          * @inheritDoc
         */
        "onVmPlaybackStarted"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the `playing` prop changes value.
          * @inheritDoc
         */
        "onVmPlayingChange"?: (event: CustomEvent<PlayerProps['playing']>) => void;
        /**
          * Emitted when the player has loaded and is ready to be interacted with.
          * @inheritDoc
         */
        "onVmReady"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted directly after the player has successfully transitioned/seeked to a new time position. Event flow: `seeking` -> `seeked`.
          * @inheritDoc
         */
        "onVmSeeked"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the `seeking` prop changes value.
          * @inheritDoc
         */
        "onVmSeekingChange"?: (event: CustomEvent<PlayerProps['seeking']>) => void;
        /**
          * Emitted when the `isTextTrackVisible` prop changes value.
          * @inheritDoc
         */
        "onVmTextTrackVisibleChange"?: (event: CustomEvent<PlayerProps['isTextTrackVisible']>) => void;
        /**
          * Emitted when the `textTracks` prop changes value.
          * @inheritDoc
         */
        "onVmTextTracksChange"?: (event: CustomEvent<PlayerProps['textTracks']>) => void;
        /**
          * Emitted when the `theme` prop changes value.
          * @inheritDoc
         */
        "onVmThemeChange"?: (event: CustomEvent<PlayerProps['theme']>) => void;
        /**
          * Emitted when the `isTouch` prop changes value.
          * @inheritDoc
         */
        "onVmTouchChange"?: (event: CustomEvent<PlayerProps['isTouch']>) => void;
        /**
          * Emitted when the `translations` prop changes value.
          * @inheritDoc
         */
        "onVmTranslationsChange"?: (event: CustomEvent<PlayerProps['translations']>) => void;
        /**
          * Emitted when the `viewType` prop changes value.
          * @inheritDoc
         */
        "onVmViewTypeChange"?: (event: CustomEvent<PlayerProps['viewType']>) => void;
        /**
          * Emitted when the `volume` prop changes value.
          * @inheritDoc
         */
        "onVmVolumeChange"?: (event: CustomEvent<PlayerProps['volume']>) => void;
        /**
          * Whether playback should be paused. Defaults to `true` if no media has loaded or playback has not started. Setting this to `true` will begin/resume playback.
          * @inheritDoc
         */
        "paused"?: boolean;
        /**
          * Whether media playback has reached the end. In other words it'll be true if `currentTime === duration`.
          * @inheritDoc 
          * @readonly
         */
        "playbackEnded"?: boolean;
        /**
          * The media qualities available for the current media.
          * @inheritDoc 
          * @readonly
         */
        "playbackQualities"?: string[];
        /**
          * Indicates the quality of the media. The value will differ between audio and video. For audio this might be some combination of the encoding format (AAC, MP3), bitrate in kilobits per second (kbps) and sample rate in kilohertz (kHZ). For video this will be the number of vertical pixels it supports. For example, if the video has a resolution of `1920x1080` then the quality will return `1080p`. Defaults to `undefined` which you can interpret as the quality is unknown. The value can also be `Auto` for adaptive bit streams (ABR), where the provider can automatically manage the playback quality. The quality can only be set to a quality found in the `playbackQualities` prop. Some providers may not allow changing the quality, you can check if it's possible via `canSetPlaybackQuality()`.
          * @inheritDoc
         */
        "playbackQuality"?: string;
        /**
          * A `double` indicating the rate at which media is being played back. If the value is `<1` then playback is slowed down; if `>1` then playback is sped up. Defaults to `1`. The playback rate can only be set to a rate found in the `playbackRates` prop. Some providers may not allow changing the playback rate, you can check if it's possible via `canSetPlaybackRate()`.
          * @inheritDoc
         */
        "playbackRate"?: number;
        /**
          * The playback rates available for the current media.
          * @inheritDoc 
          * @readonly
         */
        "playbackRates"?: number[];
        /**
          * Whether media is ready for playback to begin.
          * @inheritDoc 
          * @readonly
         */
        "playbackReady"?: boolean;
        /**
          * Whether the media has initiated playback. In other words it will be true if `currentTime > 0`.
          * @inheritDoc 
          * @readonly
         */
        "playbackStarted"?: boolean;
        /**
          * Whether media is actively playing back. Defaults to `false` if no media has loaded or playback has not started.
          * @inheritDoc 
          * @readonly
         */
        "playing"?: boolean;
        /**
          * Whether the video is to be played "inline", that is within the element's playback area. Note that setting this to false does not imply that the video will always be played in fullscreen. Depending on the provider, changing this prop may cause the player to completely reset.
          * @inheritDoc
         */
        "playsinline"?: boolean;
        /**
          * Whether the player has loaded and is ready to be interacted with.
          * @inheritDoc 
          * @readonly
         */
        "ready"?: boolean;
        /**
          * Whether the player is in the process of seeking to a new time position.
          * @inheritDoc 
          * @readonly
         */
        "seeking"?: boolean;
        /**
          * Whether text tracks should be rendered by native player, set to `false` if using custom display.
          * @inheritDoc
         */
        "shouldRenderNativeTextTracks"?: boolean;
        /**
          * The text tracks associated with the current media.
          * @inheritDoc 
          * @readonly
         */
        "textTracks"?: never[];
        /**
          * This property has no role other than scoping CSS selectors.
          * @inheritDoc
         */
        "theme"?: string;
        /**
          * Contains each language and its respective translation map.
          * @inheritDoc
         */
        "translations"?: Record<string, Translation>;
        /**
          * The type of player view that is being used, whether it's an audio player view or video player view. Normally if the media type is of audio then the view is of type audio, but in some cases it might be desirable to show a different view type. For example, when playing audio with a poster. This is subject to the provider allowing it. Defaults to `undefined` when no media has been loaded.
          * @inheritDoc 
          * @readonly
         */
        "viewType"?: ViewType;
        /**
          * An `int` between `0` (silent) and `100` (loudest) indicating the audio volume.
          * @inheritDoc
         */
        "volume"?: number;
    }
    interface VmPoster {
        "currentPoster"?: PlayerProps['currentPoster'];
        "currentTime"?: PlayerProps['currentTime'];
        /**
          * How the poster image should be resized to fit the container (sets the `object-fit` property).
         */
        "fit"?: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none';
        "isVideoView"?: PlayerProps['isVideoView'];
        "mediaTitle"?: PlayerProps['mediaTitle'];
        /**
          * Emitted when the poster has loaded.
         */
        "onVmLoaded"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the poster will be hidden.
         */
        "onVmWillHide"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the poster will be shown.
         */
        "onVmWillShow"?: (event: CustomEvent<void>) => void;
        "playbackStarted"?: PlayerProps['playbackStarted'];
    }
    interface VmScrim {
        /**
          * If this prop is defined, a dark gradient that smoothly fades out without being noticed will be used instead of a set color. This prop also sets the direction in which the dark end of the gradient should start. If the direction is set to `up`, the dark end of the gradient will start at the bottom of the player and fade out to the center. If the direction is set to `down`, the gradient will start at the top of the player and fade out to the center.
         */
        "gradient"?: 'up' | 'down';
        "isControlsActive"?: PlayerProps['isControlsActive'];
        "isVideoView"?: PlayerProps['isVideoView'];
    }
    interface VmScrubberControl {
        /**
          * Whether the timestamp in the tooltip should show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours"?: boolean;
        "buffered"?: PlayerProps['buffered'];
        "buffering"?: PlayerProps['buffering'];
        "currentTime"?: PlayerProps['currentTime'];
        "duration"?: PlayerProps['duration'];
        /**
          * Whether the tooltip should not be displayed.
         */
        "hideTooltip"?: boolean;
        "i18n"?: PlayerProps['i18n'];
        /**
          * Prevents seeking forward/backward by using the Left/Right arrow keys.
         */
        "noKeyboard"?: boolean;
    }
    interface VmSettings {
        /**
          * Whether the settings menu is opened/closed.
         */
        "active"?: boolean;
        "isAudioView"?: PlayerProps['isAudioView'];
        "isMobile"?: PlayerProps['isMobile'];
        /**
          * Pins the settings to the defined position inside the video player. This has no effect when the view is of type `audio` (always `bottomRight`) and on mobile devices (always bottom sheet).
         */
        "pin"?: 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';
    }
    interface VmSettingsControl {
        /**
          * Whether the settings menu this control manages is open.
         */
        "expanded"?: boolean;
        "i18n"?: PlayerProps['i18n'];
        /**
          * The name of the settings icon to resolve from the icon library.
         */
        "icon"?: string;
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        /**
          * The DOM `id` of the settings menu this control is responsible for opening/closing.
         */
        "menu"?: string;
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection"?: TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition"?: TooltipPosition;
    }
    interface VmSkeleton {
        /**
          * Determines which animation effect the skeleton will use.
         */
        "effect"?: 'sheen' | 'none';
        "ready"?: PlayerProps['ready'];
    }
    interface VmSlider {
        /**
          * A human-readable label for the purpose of the slider.
         */
        "label"?: string;
        /**
          * The greatest permitted value.
         */
        "max"?: number;
        /**
          * The lowest value in the range of permitted values.
         */
        "min"?: number;
        /**
          * Emitted when the slider loses focus.
         */
        "onVmBlur"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the slider receives focus.
         */
        "onVmFocus"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the value of the underlying `input` field changes.
         */
        "onVmValueChange"?: (event: CustomEvent<number>) => void;
        /**
          * A number that specifies the granularity that the value must adhere to.
         */
        "step"?: number;
        /**
          * The current value.
         */
        "value"?: number;
        /**
          * Human-readable text alternative for the current value. Defaults to `value:max` percentage.
         */
        "valueText"?: string;
    }
    interface VmSpinner {
        "buffering"?: PlayerProps['buffering'];
        "currentProvider"?: PlayerProps['currentProvider'];
        "isVideoView"?: PlayerProps['isVideoView'];
        /**
          * Emitted when the spinner will be hidden.
         */
        "onVmWillHide"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the spinner will be shown.
         */
        "onVmWillShow"?: (event: CustomEvent<void>) => void;
        "playbackReady"?: PlayerProps['playbackReady'];
        /**
          * Whether the spinner should be active when the player is booting or media is loading.
         */
        "showWhenMediaLoading"?: boolean;
    }
    interface VmSubmenu {
        /**
          * Whether the submenu is open/closed.
         */
        "active"?: boolean;
        /**
          * This can provide additional context about the current state of the submenu. For example, the hint could be the currently selected option if the submenu contains a radio group.
         */
        "hint"?: string;
        /**
          * The title of the submenu.
         */
        "label": string;
        /**
          * Emitted when the submenu has closed/is not active.
         */
        "onVmCloseSubmenu"?: (event: CustomEvent<HTMLVmSubmenuElement>) => void;
        /**
          * Emitted when the submenu is open/active.
         */
        "onVmOpenSubmenu"?: (event: CustomEvent<HTMLVmSubmenuElement>) => void;
        /**
          * The direction the submenu should slide in from.
         */
        "slideInDirection"?: 'left' | 'right';
    }
    interface VmTime {
        /**
          * Whether the time should always show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours"?: boolean;
        /**
          * The `aria-label` property of the time.
         */
        "label": string;
        /**
          * The length of time in seconds.
         */
        "seconds"?: number;
    }
    interface VmTimeProgress {
        /**
          * Whether the times should always show the hours unit, even if the time is less than 1 hour (eg: `20:35` -> `00:20:35`).
         */
        "alwaysShowHours"?: boolean;
        /**
          * The string used to separate the current time and end time.
         */
        "separator"?: string;
    }
    interface VmTooltip {
        /**
          * Whether the tooltip is visible or not.
         */
        "active"?: boolean;
        /**
          * Determines if the tooltip should grow according to its contents to the left/right. By default content grows outwards from the center.
         */
        "direction"?: TooltipDirection;
        /**
          * Whether the tooltip is displayed or not.
         */
        "hidden"?: boolean;
        "isMobile"?: PlayerProps['isMobile'];
        "isTouch"?: PlayerProps['isTouch'];
        /**
          * Determines if the tooltip appears on top/bottom of it's parent.
         */
        "position"?: TooltipPosition;
    }
    interface VmUi {
        "isFullscreenActive"?: PlayerProps['isFullscreenActive'];
        "isVideoView"?: PlayerProps['isVideoView'];
        "playsinline"?: PlayerProps['playsinline'];
    }
    interface VmVideo {
        /**
          * **EXPERIMENTAL:** Whether the browser should automatically toggle picture-in-picture mode as the user switches back and forth between this document and another document or application.
          * @inheritdoc
         */
        "autoPiP"?: boolean;
        /**
          * Determines what controls to show on the media element whenever the browser shows its own set of controls (e.g. when the controls attribute is specified).
          * @inheritdoc
         */
        "controlsList"?: string;
        /**
          * Whether to use CORS to fetch the related image. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) for more information.
          * @inheritdoc
         */
        "crossOrigin"?: MediaCrossOriginOption;
        /**
          * **EXPERIMENTAL:** Prevents the browser from suggesting a picture-in-picture context menu or to request picture-in-picture automatically in some cases.
          * @inheritdoc
         */
        "disablePiP"?: boolean;
        /**
          * **EXPERIMENTAL:** Whether to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc).
          * @inheritdoc
         */
        "disableRemotePlayback"?: boolean;
        "hasCustomTextManager"?: boolean;
        /**
          * The title of the current media.
         */
        "mediaTitle"?: string;
        /**
          * A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.
          * @inheritdoc
         */
        "poster"?: string;
        /**
          * Provides a hint to the browser about what the author thinks will lead to the best user experience with regards to what content is loaded before the video is played. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload) for more information.
          * @inheritdoc
         */
        "preload"?: MediaPreloadOption;
        "willAttach"?: boolean;
    }
    interface VmVimeo {
        "aspectRatio"?: string;
        "autoplay"?: boolean;
        /**
          * Whether to display the video owner's name.
         */
        "byline"?: boolean;
        /**
          * The hexadecimal color value of the playback controls. The embed settings of the video might override this value.
         */
        "color"?: string;
        "controls"?: boolean;
        "language"?: string;
        "logger"?: Logger;
        "loop"?: boolean;
        "muted"?: boolean;
        /**
          * Turns off automatically determining the aspect ratio of the current video.
         */
        "noAutoAspectRatio"?: boolean;
        /**
          * Emitted when an error has occurred.
         */
        "onVmError"?: (event: CustomEvent<any>) => void;
        "onVmLoadStart"?: (event: CustomEvent<void>) => void;
        "playsinline"?: boolean;
        /**
          * Whether to display the video owner's portrait.
         */
        "portrait"?: boolean;
        /**
          * The absolute URL of a custom poster to be used for the current video.
         */
        "poster"?: string;
        /**
          * The Vimeo resource ID of the video to load.
         */
        "videoId": string;
    }
    interface VmVolumeControl {
        /**
          * Whether the tooltip should be hidden.
         */
        "hideTooltip"?: boolean;
        /**
          * The name of the high volume icon to resolve from the icon library.
         */
        "highVolumeIcon"?: string;
        "i18n"?: PlayerProps['i18n'];
        /**
          * The name of an icon library to use. Defaults to the library defined by the `icons` player property.
         */
        "icons"?: string;
        "isMobile"?: PlayerProps['isMobile'];
        /**
          * The name of the low volume icon to resolve from the icon library.
         */
        "lowVolumeIcon"?: string;
        /**
          * A pipe (`/`) separated string of JS keyboard keys, that when caught in a `keydown` event, will toggle the muted state of the player.
         */
        "muteKeys"?: string;
        "muted"?: PlayerProps['muted'];
        /**
          * The name of the muted volume icon to resolve from the icon library.
         */
        "mutedIcon"?: string;
        /**
          * Prevents the volume being changed using the Up/Down arrow keys.
         */
        "noKeyboard"?: boolean;
        /**
          * The direction in which the tooltip should grow.
         */
        "tooltipDirection"?: TooltipDirection;
        /**
          * Whether the tooltip is positioned above/below the control.
         */
        "tooltipPosition"?: TooltipPosition;
        "volume"?: PlayerProps['volume'];
    }
    interface VmYoutube {
        "autoplay"?: boolean;
        "controls"?: boolean;
        /**
          * Whether cookies should be enabled on the embed.
         */
        "cookies"?: boolean;
        "language"?: string;
        "logger"?: Logger;
        "loop"?: boolean;
        "muted"?: boolean;
        "onVmLoadStart"?: (event: CustomEvent<void>) => void;
        "playsinline"?: boolean;
        /**
          * The absolute URL of a custom poster to be used for the current video.
         */
        "poster"?: string;
        /**
          * Whether the fullscreen control should be shown.
         */
        "showFullscreenControl"?: boolean;
        /**
          * The YouTube resource ID of the video to load.
         */
        "videoId": string;
    }
    interface IntrinsicElements {
        "vm-audio": VmAudio;
        "vm-caption-control": VmCaptionControl;
        "vm-captions": VmCaptions;
        "vm-click-to-play": VmClickToPlay;
        "vm-control": VmControl;
        "vm-control-group": VmControlGroup;
        "vm-control-spacer": VmControlSpacer;
        "vm-controls": VmControls;
        "vm-current-time": VmCurrentTime;
        "vm-dailymotion": VmDailymotion;
        "vm-dash": VmDash;
        "vm-dbl-click-fullscreen": VmDblClickFullscreen;
        "vm-default-controls": VmDefaultControls;
        "vm-default-settings": VmDefaultSettings;
        "vm-default-ui": VmDefaultUi;
        "vm-embed": VmEmbed;
        "vm-end-time": VmEndTime;
        "vm-file": VmFile;
        "vm-fullscreen-control": VmFullscreenControl;
        "vm-hls": VmHls;
        "vm-icon": VmIcon;
        "vm-icon-library": VmIconLibrary;
        "vm-live-indicator": VmLiveIndicator;
        "vm-loading-screen": VmLoadingScreen;
        "vm-menu": VmMenu;
        "vm-menu-item": VmMenuItem;
        "vm-menu-radio": VmMenuRadio;
        "vm-menu-radio-group": VmMenuRadioGroup;
        "vm-mute-control": VmMuteControl;
        "vm-pip-control": VmPipControl;
        "vm-playback-control": VmPlaybackControl;
        "vm-player": VmPlayer;
        "vm-poster": VmPoster;
        "vm-scrim": VmScrim;
        "vm-scrubber-control": VmScrubberControl;
        "vm-settings": VmSettings;
        "vm-settings-control": VmSettingsControl;
        "vm-skeleton": VmSkeleton;
        "vm-slider": VmSlider;
        "vm-spinner": VmSpinner;
        "vm-submenu": VmSubmenu;
        "vm-time": VmTime;
        "vm-time-progress": VmTimeProgress;
        "vm-tooltip": VmTooltip;
        "vm-ui": VmUi;
        "vm-video": VmVideo;
        "vm-vimeo": VmVimeo;
        "vm-volume-control": VmVolumeControl;
        "vm-youtube": VmYoutube;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "vm-audio": LocalJSX.VmAudio & JSXBase.HTMLAttributes<HTMLVmAudioElement>;
            "vm-caption-control": LocalJSX.VmCaptionControl & JSXBase.HTMLAttributes<HTMLVmCaptionControlElement>;
            "vm-captions": LocalJSX.VmCaptions & JSXBase.HTMLAttributes<HTMLVmCaptionsElement>;
            "vm-click-to-play": LocalJSX.VmClickToPlay & JSXBase.HTMLAttributes<HTMLVmClickToPlayElement>;
            "vm-control": LocalJSX.VmControl & JSXBase.HTMLAttributes<HTMLVmControlElement>;
            "vm-control-group": LocalJSX.VmControlGroup & JSXBase.HTMLAttributes<HTMLVmControlGroupElement>;
            "vm-control-spacer": LocalJSX.VmControlSpacer & JSXBase.HTMLAttributes<HTMLVmControlSpacerElement>;
            "vm-controls": LocalJSX.VmControls & JSXBase.HTMLAttributes<HTMLVmControlsElement>;
            "vm-current-time": LocalJSX.VmCurrentTime & JSXBase.HTMLAttributes<HTMLVmCurrentTimeElement>;
            "vm-dailymotion": LocalJSX.VmDailymotion & JSXBase.HTMLAttributes<HTMLVmDailymotionElement>;
            "vm-dash": LocalJSX.VmDash & JSXBase.HTMLAttributes<HTMLVmDashElement>;
            "vm-dbl-click-fullscreen": LocalJSX.VmDblClickFullscreen & JSXBase.HTMLAttributes<HTMLVmDblClickFullscreenElement>;
            "vm-default-controls": LocalJSX.VmDefaultControls & JSXBase.HTMLAttributes<HTMLVmDefaultControlsElement>;
            "vm-default-settings": LocalJSX.VmDefaultSettings & JSXBase.HTMLAttributes<HTMLVmDefaultSettingsElement>;
            "vm-default-ui": LocalJSX.VmDefaultUi & JSXBase.HTMLAttributes<HTMLVmDefaultUiElement>;
            "vm-embed": LocalJSX.VmEmbed & JSXBase.HTMLAttributes<HTMLVmEmbedElement>;
            "vm-end-time": LocalJSX.VmEndTime & JSXBase.HTMLAttributes<HTMLVmEndTimeElement>;
            "vm-file": LocalJSX.VmFile & JSXBase.HTMLAttributes<HTMLVmFileElement>;
            "vm-fullscreen-control": LocalJSX.VmFullscreenControl & JSXBase.HTMLAttributes<HTMLVmFullscreenControlElement>;
            "vm-hls": LocalJSX.VmHls & JSXBase.HTMLAttributes<HTMLVmHlsElement>;
            "vm-icon": LocalJSX.VmIcon & JSXBase.HTMLAttributes<HTMLVmIconElement>;
            "vm-icon-library": LocalJSX.VmIconLibrary & JSXBase.HTMLAttributes<HTMLVmIconLibraryElement>;
            "vm-live-indicator": LocalJSX.VmLiveIndicator & JSXBase.HTMLAttributes<HTMLVmLiveIndicatorElement>;
            "vm-loading-screen": LocalJSX.VmLoadingScreen & JSXBase.HTMLAttributes<HTMLVmLoadingScreenElement>;
            "vm-menu": LocalJSX.VmMenu & JSXBase.HTMLAttributes<HTMLVmMenuElement>;
            "vm-menu-item": LocalJSX.VmMenuItem & JSXBase.HTMLAttributes<HTMLVmMenuItemElement>;
            "vm-menu-radio": LocalJSX.VmMenuRadio & JSXBase.HTMLAttributes<HTMLVmMenuRadioElement>;
            "vm-menu-radio-group": LocalJSX.VmMenuRadioGroup & JSXBase.HTMLAttributes<HTMLVmMenuRadioGroupElement>;
            "vm-mute-control": LocalJSX.VmMuteControl & JSXBase.HTMLAttributes<HTMLVmMuteControlElement>;
            "vm-pip-control": LocalJSX.VmPipControl & JSXBase.HTMLAttributes<HTMLVmPipControlElement>;
            "vm-playback-control": LocalJSX.VmPlaybackControl & JSXBase.HTMLAttributes<HTMLVmPlaybackControlElement>;
            "vm-player": LocalJSX.VmPlayer & JSXBase.HTMLAttributes<HTMLVmPlayerElement>;
            "vm-poster": LocalJSX.VmPoster & JSXBase.HTMLAttributes<HTMLVmPosterElement>;
            "vm-scrim": LocalJSX.VmScrim & JSXBase.HTMLAttributes<HTMLVmScrimElement>;
            "vm-scrubber-control": LocalJSX.VmScrubberControl & JSXBase.HTMLAttributes<HTMLVmScrubberControlElement>;
            "vm-settings": LocalJSX.VmSettings & JSXBase.HTMLAttributes<HTMLVmSettingsElement>;
            "vm-settings-control": LocalJSX.VmSettingsControl & JSXBase.HTMLAttributes<HTMLVmSettingsControlElement>;
            "vm-skeleton": LocalJSX.VmSkeleton & JSXBase.HTMLAttributes<HTMLVmSkeletonElement>;
            "vm-slider": LocalJSX.VmSlider & JSXBase.HTMLAttributes<HTMLVmSliderElement>;
            "vm-spinner": LocalJSX.VmSpinner & JSXBase.HTMLAttributes<HTMLVmSpinnerElement>;
            "vm-submenu": LocalJSX.VmSubmenu & JSXBase.HTMLAttributes<HTMLVmSubmenuElement>;
            "vm-time": LocalJSX.VmTime & JSXBase.HTMLAttributes<HTMLVmTimeElement>;
            "vm-time-progress": LocalJSX.VmTimeProgress & JSXBase.HTMLAttributes<HTMLVmTimeProgressElement>;
            "vm-tooltip": LocalJSX.VmTooltip & JSXBase.HTMLAttributes<HTMLVmTooltipElement>;
            "vm-ui": LocalJSX.VmUi & JSXBase.HTMLAttributes<HTMLVmUiElement>;
            "vm-video": LocalJSX.VmVideo & JSXBase.HTMLAttributes<HTMLVmVideoElement>;
            "vm-vimeo": LocalJSX.VmVimeo & JSXBase.HTMLAttributes<HTMLVmVimeoElement>;
            "vm-volume-control": LocalJSX.VmVolumeControl & JSXBase.HTMLAttributes<HTMLVmVolumeControlElement>;
            "vm-youtube": LocalJSX.VmYoutube & JSXBase.HTMLAttributes<HTMLVmYoutubeElement>;
        }
    }
}
